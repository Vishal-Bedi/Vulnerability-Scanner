import sys
from subprocess import STDOUT, check_output
import os
from requests import Session, Request
import re
import urllib3
import argparse
from pymetasploit3.msfrpc import MsfRpcClient
import socket
from OpenSSL import SSL
from service_identity import VerificationError
from cryptography import x509
from cryptography.x509.oid import NameOID
import idna
import signal
import concurrent.futures
from collections import namedtuple
import requests
import threading
import queue
from datetime import datetime, timedelta
import time
import xlsxwriter
from random import randrange
from scapy.all import *
import socket 
import sys 
from termcolor import colored, cprint 


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

#DNS Cache snooping
#HTTPS Enforced check
#BIGIP timeout 
#BIGIP grep for port
#extractPath check (Win not working)
#check ssl enabled https://stackoverflow.com/questions/51423507/how-to-extract-an-ssl-tls-message-using-scapy-and-python
#ssl check https://gist.github.com/gdamjan/55a8b9eec6cf7b771f92021d93b87b2c

start=time.time()

ipList = set()
expiredCerts = {}
soonToExpireCerts = {}
anonCiphersStore = {}
httpsNotEnforced = {}
httpsNotEnabled = {}
verboseServerBannerContentStore = {}
verboseServerBannerStore = {}
hostHeaderInjectionStore = {}
HSTSMisconfig = {}
internalIPDisclosureStore = {}
bigIPDisclosureStore = {}
ssrfStore = {} 
verboseServerErrorStore = {}
extractPathStore = {}
TLS1 = {}
SSL3 = {}
SSL2 = {}
ntpStore = {}
numerOfRedirects = 0
missingOrInsecureHeaders = {}
storeOpenPorts = {}
traceEnabled = {}
dnsPortCheck = set()
dnsDOSStore = {}

workbook = xlsxwriter.Workbook('Vulnerability_Results.xlsx') 
bold = workbook.add_format({'bold': True})
cell_format = workbook.add_format()
cell_format.set_text_wrap()
worksheet = workbook.add_worksheet("SSL Vulnerabilities") 
worksheetWeb = workbook.add_worksheet("Web Vulnerabilities") 
worksheetNetwork = workbook.add_worksheet("Network Vulnerabilities") 
worksheet.write(0, 0, "Certificate Expired", bold)
worksheet.write(0, 1, "All information", bold)
worksheet.write(0, 3, "Certificate will expire soon", bold)
worksheet.write(0, 4, "All information", bold)
worksheet.write(0, 6, "Anonymous SSL/TLS ciphers supported", bold)
worksheet.write(0, 7, "All information", bold)
worksheet.write(0, 9, "HTTPS Not Enabled", bold)
worksheet.write(0, 10, "All information", bold)
worksheet.write(0, 12, "HTTPS Not Enforced", bold)
worksheet.write(0, 13, "All information", bold)
worksheet.write(0, 15, "HSTS Missing or Misconfigured", bold)
worksheet.write(0, 16, "All information", bold)
worksheet.write(0, 18, "SSLv2 Enabled", bold)
worksheet.write(0, 19, "SSLv3 Enabled", bold)
worksheet.write(0, 20, "TLSv1.0 Enabled", bold)

worksheetWeb.write(0, 0, "Verbose Server Banner", bold)
worksheetWeb.write(0, 1, "Disclosed Header", bold)
worksheetWeb.write(0, 3, "Verbose Server Banner in Response", bold)
worksheetWeb.write(0, 4, "Request Headers", bold)
worksheetWeb.write(0, 6, "Host Header Injection", bold)
worksheetWeb.write(0, 7, "Request Headers", bold)
worksheetWeb.write(0, 9, "Internal IP Disclosure", bold)
worksheetWeb.write(0, 10, "Disclosed IP Address", bold)
worksheetWeb.write(0, 12, "BigIP Cookie Internal IP Disclosure", bold)
worksheetWeb.write(0, 13, "Disclosed IP Address", bold)
worksheetWeb.write(0, 15, "Server Side Request Forgery", bold)
worksheetWeb.write(0, 16, "Vulnerable parameter", bold)
worksheetWeb.write(0, 18, "Verbose Server Error", bold)
worksheetWeb.write(0, 19, "Exception", bold)
worksheetWeb.write(0, 21, "Internal Path Disclosure", bold)
worksheetWeb.write(0, 22, "Exception", bold)
worksheetWeb.write(0, 24, "Missing or Misconfigured Headers", bold)
worksheetWeb.write(0, 25, "Information", bold)
worksheetWeb.write(0, 27, "TRACE method enabled", bold)

worksheetNetwork.write(0, 0, "Network Time Protocol (NTP) Mode 6 Scanner DOS", bold)
worksheetNetwork.write(0, 1, "Response", bold)
worksheetNetwork.write(0, 3, "Domain Name System (DNS) DOS", bold)
worksheetNetwork.write(0, 4, "Information", bold)


def signal_handler(sig, frame):
        os.system("stty sane")
        sys.exit(0)
signal.signal(signal.SIGINT, signal_handler)


#Helper Functions
def proxyError(e, method):
	
	if "Cannot connect to proxy" in str(e):
		
		if method == "scan":
			cprint("\nCannot connect to proxy\n\nPlease enable proxy to continue scanning\n", 'red', attrs=['bold'])
			sys.exit()

		else:	
			address = "https://www.google.com"
		
			while True:
				try:
					headers = None
					proxyCheck = oneRequest(headers, address)

					if proxyCheck.status_code:
						break
					else:
						
						time.sleep(2)
						continue

				except Exception as e:

					if "Cannot connect to proxy" in str(e):
						
						time.sleep(2)
						continue
					else:
						break
			return

	else:		
		return


def portOpenCheck(IP, port):

	target = IP

	def portscan(port):

	    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	    s.settimeout(0.5)# 

	    try:
	    	con = s.connect((target,port))
	    	
	    	print('Port :',port,"is open.")
	    	con.close()
	    except Exception as e: 
	    	
	    	pass
	r = 1 

	for x in range(1,100): 

	    t = threading.Thread(target=portscan,kwargs={'port':r}) 

	    r += 1     
	    t.start() 


def oneRequest(headers, address):

	if headers != None:
		result = requests.get(address, verify=False, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
	else:	
		result = requests.get(address, verify=False, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
	
	return result


def allRedirectRequests(headers, IP, port, redirectUrl):
	

	redirectUrl1 = str(redirectUrl.url)

	if "location" in str(redirectUrl.headers).lower() and "https" not in str(redirectUrl.headers["Location"]) and "http" not in str(redirectUrl.headers["Location"]):
		redirectUrl1 = "{}{}".format(str(redirectUrl.url), str(redirectUrl.headers["Location"]))
		#print(redirectUrl1)

	elif "location" in str(redirectUrl.headers).lower():
		redirectUrl1 = str(redirectUrl.url)
	
	try:
	
		redirectData = requests.get(redirectUrl1, verify=False, proxies=proxyDict, headers=headers, allow_redirects=True, timeout=(5, 8))

		return redirectData

	except Exception as e:
		 
		replace = 1
		return None


def extractPath(data, IP, port, fromMethod):

	if fromMethod == "iid":
		noChange = 1
	else:
		data = data.decode()
	
	resultPath = set()

	regWin = (re.findall( r'([a-zA-Z]\:|\\\\[^\/\\:*?"<>|]+\\[^\/\\:*?"<>|]+)(\\[^\/\\:*?"<>|]+)+(\.[^\/\\:*?"<>|]+)$', data))

	#Linux
	regex = r"((?!.*//.*)(?!.*/ .*)/{1}([^\\(){}:\*\?<>\|\"\'])+\.(cpp|deb|bz2|bin|pid|lock|iso|zip|wav|xwd|tgz|html|conf|dat))"

	matches = re.search(regex, data)
	
	if matches == None or "/js/" in matches.group():
		empty = 1

	else:
		resultPath.add("{}".format(matches))
		instance = "{}:{}".format(IP, port)
		extractPathStore.update({instance:str(matches.group())})

	if regWin == []:
		empty = 1
	else:
		resultPath.add("{}".format(regWin))
		instance = "{}:{}".format(IP, port)
		extractPathStore.update({instance:str(regWin)})

	if extractPathStore == {} and fromMethod == "iid":
		print(colored('{0:<40}'.format("Internal Path Disclosure:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	elif extractPathStore != {} and fromMethod == "iid":
		converted = ', '.join(resultPath)
		instance = "{}:{}".format(IP, port)
		str1 = ''.join(extractPathStore[instance])
		print(colored('{0:<40}'.format("Internal Path Disclosure:"), 'white', attrs=['bold']), colored("Vulnerable: {}".format(extractPathStore[instance]), 'red'))

	

def extractIP(extractIPFromString, IP, port, data):

	regex = (re.findall( r'(?:[\d]{1,3})\.(?:[\d]{1,3})\.(?:[\d]{1,3})\.(?:[\d]{1,3})', str(extractIPFromString)))
	import json

	resultInternalIP = set()
	for ip in regex:

		if ip.startswith("10.") or ip.startswith("192.168."):
			resultInternalIP.add("Vulnerable: {}".format(ip))
			ipList.add(ip)

			if data == "iid":
				instance = "{}:{}".format(IP, port)
				internalIPDisclosureStore.update({instance:str(ip)})

			if data == "msfconsole":
				instance = "{}:{}".format(IP, port)
				bigIPDisclosureStore.update({instance:str(ip)})

		elif ip.startswith("172.") and int(ip.split(".")[1]) >= 16 and int(ip.split(".")[1]) <= 31:
			resultInternalIP.add("Vulnerable: {}".format(ip))
			ipList.add(ip)

			if data == "iid":
				instance = "{}:{}".format(IP, port)
				internalIPDisclosureStore.update({instance:str(ip)})

			if data == "msfconsole":
				instance = "{}:{}".format(IP, port)
				bigIPDisclosureStore.update({instance:str(ip)})

	if len(resultInternalIP) == 0:
		print(colored('{0:<40}'.format("Internal IP Disclosure:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	else:
		converted = ', '.join(resultInternalIP)
		print(colored('{0:<40}'.format("Internal IP Disclosure:"), 'white', attrs=['bold']), colored(converted, 'red'))



def msfconsole(IP, port):
	
	try:
		client = MsfRpcClient('toortoor', port=55553, ssl=True)
	except:
		return

	exploit = client.modules.use('auxiliary','gather/f5_bigip_cookie_disclosure')
	exploit['RHOSTS'] = IP
	exploit['RPORT'] = int(port)
	exploit['SSL']= False

	try:
		console_id = client.consoles.console().cid
		console = client.consoles.console(console_id)
		extractIP(console.run_module_with_output(exploit), IP, port, "msfconsole")

	except:
		cprint ("Connection failed", 'red', attrs=['bold'])


def hstsCheck(data, IP, port):
		
	if 'strict-transport-security' not in data.headers:
		print(colored('{0:<40}'.format("strict-transport-security:"), 'white', attrs=['bold']), colored("Header Missing", 'red'))
		instance = "{}:{}".format(IP, port)
		HSTSMisconfig.update({instance:"Missing"})

	else:
		values = data.headers['strict-transport-security']
		max_age = int("".join(filter(str.isdigit, values)))
		
		if 'max-age' not in data.headers['strict-transport-security'] or max_age < 10886400:
			print(colored('{0:<40}'.format("strict-transport-security:"), 'white', attrs=['bold']), colored("HSTS not implemented properly: max-age should be at least eighteen weeks", 'red'))
			instance = "{}:{}".format(IP, loopPorts)
			HSTSMisconfig.update({instance:"Misconfigured"})

		else:
			print(colored('{0:<40}'.format("strict-transport-security:"), 'white', attrs=['bold']), colored("Implemented Correctly", 'green'))


#Network Functions
def ntpMode6(IPAddress):

	print(colored('{0:<40}'.format("Network Time Protocol DOS:"), 'white', attrs=['bold']), colored("", 'yellow'), end="\r")
	ntpserver = IPAddress
	data = "\x16\x02\x00\x01" + "\x00" * 8
	
	packets = IP(dst=ntpserver)/UDP(sport=48947,dport=123)/Raw(load=data) 
	send(packets, verbose=0)
	resultNTP = sniff(iface="eth0",timeout = 2)

	flag = 0
	try:
		for i in range (0,9):
					
			if "processor" in str(resultNTP[i]) and "rootdelay" in str(resultNTP[i]):
				flag = 1
				print(colored('{0:<40}'.format("Network Time Protocol DOS:"), 'white', attrs=['bold']), colored("NTP Server replied to Mode 6 queries. Potential to be used in NTP amplification attacks", 'red'))
				instance = str(IPAddress) + ":123u"
				ntpStore.update({instance:str(resultNTP[i])})
				break

	except Exception as e:
			replace = 1
			
	if flag == 0:
		print(colored('{0:<40}'.format("Network Time Protocol DOS:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
				


def dnsDOS(IPAddress):

	print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("", 'yellow'), end="\r")
	query_types = ["ANY", "A","AAAA","CNAME","MX","NS","PTR","CERT","SRV","TXT", "SOA"]
	query_name = "www.google.com"
	time_to_live = 128 

	query = ""
	queryResult = {}
	for queryType in query_types:
		packet = IP(dst=IPAddress, ttl=time_to_live) / UDP() / DNS(rd=1, qd=DNSQR(qname=query_name, qtype=queryType))

		try:
			query = sr1(packet,verbose=False, timeout=8)
			ampFactor = len(query) / len(packet)
			queryResult.update({queryType:ampFactor})

		except Exception as e:
			#print(e)
			errorReceived = 1
	
	
	count = 0
	if queryResult != {}:
		for i in queryResult:
			if queryResult.get(i) > count:
				try:
					storeHighestValue = "Query Type: {}, Amplification Factor: {}, Request: {} bytes, Response: {} bytes".format(i, queryResult.get(i), len(query), len(packet))
				except:
					continue

	try:
		if queryResult != {}:
			if query[DNS].ra == 0:
		
				if ampFactor < 4:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Disabled".format(storeHighestValue), 'green'))
				elif ampFactor >= 4 and ampFactor <= 8:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Disabled".format(storeHighestValue), 'yellow'))
				elif ampFactor > 8:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Disabled".format(storeHighestValue), 'red'))

			elif query[DNS].ra == 1:

				if ampFactor < 4:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Enabled".format(storeHighestValue), 'green'))
				elif ampFactor >= 4 and ampFactor <= 8:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Enabled".format(storeHighestValue), 'yellow'))
				elif ampFactor > 8:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Enabled".format(storeHighestValue), 'red'))

			dnsDOSStore.update({IPAddress:storeHighestValue})
		else:
			print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("Error connecting to server\n", 'yellow'))
	except:
		print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("Error connecting to server\n", 'yellow'))



def dnsCacheSnooping(IPAddress):

	import ipaddress

	print(colored('{0:<40}'.format("Domain Name System Cache Snooping:"), 'white', attrs=['bold']), colored("", 'yellow'), end="\r")

	domainList = ["google.com","facebook.com","youtube.com","yahoo.com","baidu.com","wikipedia.org","amazon.com","qq.com","live.com","linkedin.com","twitter.com","blogspot.com","taobao.com","google.co.in","bing.com",
  "yahoo.co.jp","yandex.ru","wordpress.com","sina.com.cn","vk.com","ebay.com","google.de","tumblr.com","msn.com","google.co.uk","googleusercontent.com","ask.com","mail.ru","google.com.br","163.com","google.fr","pinterest.com",
  "google.com.hk","hao123.com","microsoft.com","google.co.jp","xvideos.com","google.ru","weibo.com","craigslist.org","paypal.com","instagram.com","amazon.co.jp","google.it","imdb.com","blogger.com","google.es","apple.com",
  "conduit.com","sohu.com",]

	time_to_live = 128
	vulnerable = 0
	for domainName in domainList:
			packet = IP(dst=IPAddress, ttl=time_to_live) / UDP() / DNS(rd=0, qd=DNSQR(qname=domainName))

			try:
					query = sr1(packet,verbose=False, timeout=8)
					if query.haslayer(DNSRR):

							result = repr(query[DNSRR].rdata)
							result = result.split("'")

							if ipaddress.ip_address(result[1]):
								vulnerable = 1

			except Exception as e:
					#print(e)
					replace = 1

	if vulnerable == 1:
		print(colored('{0:<40}'.format("Domain Name System Cache Snooping:"), 'white', attrs=['bold']), colored("Vulnerable\n", 'yellow'))
	else:
		print(colored('{0:<40}'.format("Domain Name System Cache Snooping:"), 'white', attrs=['bold']), colored("Not Vulnerable\n", 'yellow'))


#SSL Functions
def anonCiphers(IP, port):

	try:
		import nmap
		
		argument = "-Pn --script ssl-enum-ciphers -p%s" %port

		nm = nmap.PortScanner()
		nm.scan(IP, arguments=argument)

		storeResult = nm[IP]['tcp'][int(port)]

		storeResult = storeResult.get('script', {}).get('ssl-enum-ciphers')
		
		if "SSLv2:" in str(storeResult):
				print(colored('{0:<40}'.format("SSLv2:"), 'white', attrs=['bold']), colored("Enabled", 'red'))
				instance =  "{}:{}".format(IP, port)
				SSL2.update({instance:str(storeResult)})

		else:
				print(colored('{0:<40}'.format("SSLv2:"), 'white', attrs=['bold']), colored("Not Enabled", 'green'))


		if "SSLv3:" in str(storeResult):
				print(colored('{0:<40}'.format("SSLv3:"), 'white', attrs=['bold']), colored("Enabled", 'red'))
				instance = "{}:{}".format(IP, port)
				SSL3.update({instance:str(storeResult)})
		else:
				print(colored('{0:<40}'.format("SSLv3:"), 'white', attrs=['bold']), colored("Not Enabled", 'green'))

		if "TLSv1.0:" in str(storeResult):
				print(colored('{0:<40}'.format("TLSv1.0:"), 'white', attrs=['bold']), colored("Enabled", 'red'))
				instance = "{}:{}".format(IP, port)
				TLS1.update({instance:str(storeResult)})
		else:
				print(colored('{0:<40}'.format("TLSv1.0:"), 'white', attrs=['bold']), colored("Not Enabled", 'green'))

		if "TLSv1.1:" in str(storeResult):
				print(colored('{0:<40}'.format("TLSv1.1:"), 'white', attrs=['bold']), colored("Enabled", 'white'))
				instance = "{}:{}".format(IP, port)
				TLS1.update({instance:str(storeResult)})
		else:
				print(colored('{0:<40}'.format("TLSv1.1:"), 'white', attrs=['bold']), colored("Not Enabled", 'white'))

		if "TLSv1.2:" in str(storeResult):
				print(colored('{0:<40}'.format("TLSv1.2:"), 'white', attrs=['bold']), colored("Enabled", 'white'))
				instance = "{}:{}".format(IP, port)
				TLS1.update({instance:str(storeResult)})
		else:
				print(colored('{0:<40}'.format("TLSv1.2:"), 'white', attrs=['bold']), colored("Not Enabled", 'white'))


		if "least strength:" in str(storeResult):

			if "least strength: C" in str(storeResult):
				print(colored('{0:<40}'.format("Weak SSL/TLS Ciphers Enabled:"), 'white', attrs=['bold']), colored("Vulnerable", 'red'))
				instance = "{}:{}".format(IP, port)
				anonCiphersStore.update({instance:str(storeResult)})
			else:
				print(colored('{0:<40}'.format("Weak SSL/TLS Ciphers Enabled:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))

		else:
			print(colored('{0:<40}'.format("Weak SSL/TLS Ciphers Enabled:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
			return

	except Exception as e:
		print(colored('{0:<40}'.format("Weak SSL/TLS Ciphers Enabled:"), 'white', attrs=['bold']), colored("¯\\_(ツ)_/¯", 'green'))
		replace = 1
		return


def hsts(data, IP, port, status):

				
	if "https" in status or "ssl" in status:
		
		try:
			hstsCheck(data, IP, port)

		except requests.exceptions.RequestException as e:
			 
			replace = 1
			exception = 1
			
	else:
		return


def httpsEnforced(IP, port):


	headers = {'Host': 'www.oteri.com', 'Upgrade-Insecure-Requests':'1', \
	'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
	'Connection': 'close'} 
	
	address = "http://{}:{}".format(IP, port)
	
	try:
		SSLcon = oneRequest(headers, address)
	
		if "location" in str((SSLcon.headers)).lower():

			if "https" in SSLcon.headers['Location'].lower():
				print(colored('{0:<40}'.format("HTTPS Enforced:"), 'white', attrs=['bold']), colored("True", 'green'))

			else:
				enabled = 1
				try:
					addreSSL = "https://{}:{}".format(IP, port)
					SSLcon = oneRequest(headers, addreSSL)
				except:	
					enabled = 0
					print(colored('{0:<40}'.format("HTTPS Enabled:"), 'white', attrs=['bold']), colored("False", 'red'))
					instance = "{}:{}".format(IP, port)
					httpsNotEnabled.update({instance:"Disabled"})
				
				if enabled == 1:
					print(colored('{0:<40}'.format("HTTPS Enforced:"), 'white', attrs=['bold']), colored("False", 'red'))
					instance = "{}:{}".format(IP, port)
					httpsNotEnforced.update({instance:"HTTPS Not Enforced"})

		else:

			try:
				addreSSL = "https://{}:{}".format(IP, port)
				SSLcon = oneRequest(headers, addreSSL)

				if SSLcon.status_code != None:
					print(colored('{0:<40}'.format("HTTPS Enabled:"), 'white', attrs=['bold']), colored("True", 'green'))
					enabled = 1
			except:	
				enabled = 0
				print(colored('{0:<40}'.format("HTTPS Enabled:"), 'white', attrs=['bold']), colored("False", 'red'))
				instance = "{}:{}".format(IP, port)
				httpsNotEnabled.update({instance:"Disabled"})

			if enabled == 1:
				print(colored('{0:<40}'.format("HTTPS Enforced:"), 'white', attrs=['bold']), colored("False", 'red'))
				instance = "{}:{}".format(IP, port)
				httpsNotEnforced.update({instance:"HTTPS Not Enforced"})


	except requests.exceptions.RequestException as e:

		print(colored('{0:<40}'.format("HTTPS Enabled:"), 'white', attrs=['bold']), colored("¯\\_(ツ)_/¯", 'yellow'))
		print(colored('{0:<40}'.format("HTTPS Enforced:"), 'white', attrs=['bold']), colored("¯\\_(ツ)_/¯", 'yellow'))
		replace = 1
		exception = 1
		proxyError(e, "")
		

def ssl(IP, loopPorts, status):

	HostInfo = namedtuple(field_names='cert hostname peername', typename='HostInfo')
	from socket import socket

	if "https" in status or "ssl" in status:
		
		anonCiphers(IP, loopPorts)
		httpsEnforced(IP, loopPorts)
		
		HOSTS = [(IP, int(loopPorts))]
		
		try:
			def get_certificate(hostnames, port):

			    hostname = hostnames[0][0]
			    port = hostnames[0][1]
			    hostname = str(hostname)
			    hostname_idna = idna.encode(hostname)
			    sock = socket()

			    sock.connect((hostname, port))
			    peername = sock.getpeername()
			    ctx = SSL.Context(SSL.SSLv23_METHOD) # most compatible
			    ctx.check_hostname = False
			    ctx.verify_mode = SSL.VERIFY_NONE

			    sock_ssl = SSL.Connection(ctx, sock)
			    sock_ssl.set_connect_state()
			    sock_ssl.set_tlsext_host_name(hostname_idna)				    
			    sock_ssl.do_handshake()
			    cert = sock_ssl.get_peer_certificate()
			    crypto_cert = cert.to_cryptography()
			    sock_ssl.close()
			    sock.close()

			    return HostInfo(cert=crypto_cert, peername=peername, hostname=hostname)

			def get_alt_names(cert):
			    
			    try:
			        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName)
			        return ext.value.get_values_for_type(x509.DNSName)
			    except x509.ExtensionNotFound:
			        return None

			def get_common_name(cert):
			    
			    try:
			        names = cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)
			        return names[0].value
			    except x509.ExtensionNotFound:
			        return None

			def get_issuer(cert):
			    
			    try:
			        names = cert.issuer.get_attributes_for_oid(NameOID.COMMON_NAME)
			        return names[0].value
			    except x509.ExtensionNotFound:
			        return None


			def print_basic_info(hostinfo):

			    
			    #print(hostinfo.cert.not_valid_after)
			    datetimes = hostinfo.cert.not_valid_after
			    datetimes = str(datetimes)
			    datetimes = datetimes.split(" ")
			    datetimes = datetimes[0].split("-")
			    present = datetime.now()
			    #print(datetimes[0])
			    #print(datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) < present)

			    s = '''\n» {hostname} « … {peername}
			    \tcommonName: {commonname}
			    \tSAN: {SAN}
			    \tissuer: {issuer}
			    \tnotBefore: {notbefore}
			    \tnotAfter:  {notafter}
			    '''.format(
			            hostname=hostinfo.hostname,
			            peername=hostinfo.peername,
			            commonname=get_common_name(hostinfo.cert),
			            SAN=get_alt_names(hostinfo.cert),
			            issuer=get_issuer(hostinfo.cert),
			            notbefore=hostinfo.cert.not_valid_before,
			            notafter=hostinfo.cert.not_valid_after
			    )
			    
			    if (datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) < present) == True:
			    	print(colored('{0:<40}'.format("Certificate Expiry:"), 'white', attrs=['bold']), colored("Expired", 'red'))
			    	instance = "{}:{}".format(IP, loopPorts)
			    	expiredCerts.update({instance:str(s)})
			    else:
				    daysRemaining = str(datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) - present)
				    daysRemaining = daysRemaining.split(" ")
				    
				    if int(daysRemaining[0]) <= 60:
				    	print(colored('{0:<40}'.format("Certificate Expiry:"), 'white', attrs=['bold']), colored("Certificate will expire in less than 60 days", 'yellow'))
				    	instance = "{}:{}".format(IP, loopPorts)
				    	soonToExpireCerts.update({instance:str(s)})

				    else:
				    	print(colored('{0:<40}'.format("Certificate Expiry:"), 'white', attrs=['bold']), colored("Certificate Valid", 'green'))

			    cprint(s, 'white', attrs=['bold'])

			def check_it_out(hostname, port):
			    hostinfo = get_certificate(hostname, port)
			    print_basic_info(hostinfo)

			check_it_out(HOSTS, loopPorts)

	
		except Exception as e:
			print(e)
			print(colored('{0:<40}'.format("Certificate Expiry:"), 'white', attrs=['bold']), colored("¯\\_(ツ)_/¯", 'yellow'))
			count = "buff!"
			replace = 1

	else:
		print(colored('{0:<40}'.format("Certificate Expiry:"), 'white', attrs=['bold']), colored("¯\\_(ツ)_/¯", 'yellow'))
		httpsEnforced(IP, loopPorts)


def traceMethod(IP, loopPorts, status):

	response = socketRequestHelperMethod(IP, loopPorts, status, "trace")

	if "TRACE / HTTP/1.1" in response or "message/http" in response:
		print(colored('{0:<40}'.format("TRACE HTTP Method:"), 'white', attrs=['bold']), colored("Method Enabled", 'red'))
		instance = "{}:{}".format(IP, loopPorts)
		traceEnabled.update({instance:"trace"})

	else:
		print(colored('{0:<40}'.format("TRACE HTTP Method:"), 'white', attrs=['bold']), colored("Not Enabled", 'green'))


#All Header Functions
def cacheControl(data, IP, loopPorts):

	resultCache = set()

	if "Cache-Control" in str(data.headers):
		
		if "no-cache" in str(data.headers["Cache-Control"]) and "no-store" in str(data.headers["Cache-Control"]):
			sett = 1
		
		else:
			resultCache.add("Misconfigured")
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Cache-Control: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Cache-Control: Misconfigured"})

	elif "cache-control" in str(data.headers):
		
		if "no-cache" in str(data.headers["cache-control"]) and "no-store" in str(data.headers["cache-control"]):
			sett = 1
		
		else:
			resultCache.add("Misconfigured")
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Cache-Control: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Cache-Control: Misconfigured"})

	else:
		resultCache.add("Not implemented")
		instance = "{}:{}".format(IP, loopPorts)
		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Cache-Control: Missing")
			missingOrInsecureHeaders.update({instance:newValue})
	
		else:
			missingOrInsecureHeaders.update({instance:"Cache-Control: Missing"})

	if len(resultCache) == 0:
		print(colored('{0:<40}'.format("Cache Control:"), 'white', attrs=['bold']), colored("Set", 'green'))
	
	else:
		converted = ', '.join(resultCache)
		print(colored('{0:<40}'.format("Cache Control:"), 'white', attrs=['bold']), colored(converted, 'red'))



def originHeaderCORS(data, IP, loopPorts):

	resultACAO = set()

	if "Access-Control-Allow-Origin" in str(data.headers):
		
		if "*" in str(data.headers["Access-Control-Allow-Origin"]):
			resultACAO.add("Misconfigured CORS -> Access-Control-Allow-Origin: {}".format(str(data.headers["Access-Control-Allow-Origin"])))
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Access-Control-Allow-Origin: Misconfigured - Broadly Scoped Origin")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Access-Control-Allow-Origin: Misconfigured - Broadly Scoped Origin"})

		elif "www.custom-origin-header.com" in str(data.headers["Access-Control-Allow-Origin"]):
			resultACAO.add("Misconfigured CORS -> Access-Control-Allow-Origin: {}".format(str(data.headers["Access-Control-Allow-Origin"])))
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Access-Control-Allow-Origin: Misconfigured - Origin reflected")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Access-Control-Allow-Origin: Misconfigured - Origin reflected"})

	elif "Timing-Allow-Origin" in str(data.headers):
		
		if "*" in str(data.headers["Timing-Allow-Origin"]):
			resultACAO.add("Misconfigured CORS -> Timing-Allow-Origin: {}".format(str(data.headers["Timing-Allow-Origin"])))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Timing-Allow-Origin: Misconfigured - Broadly Scoped Origin")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Timing-Allow-Origin: Misconfigured - Broadly Scoped Origin"})

		elif "www.custom-origin-header.com" in str(data.headers["Timing-Allow-Origin"]):
			resultACAO.add("Misconfigured CORS -> Timing-Allow-Origin: {}".format(str(data.headers["Timing-Allow-Origin"])))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Timing-Allow-Origin: Misconfigured - Origin reflected")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Timing-Allow-Origin: Misconfigured - Origin reflected"})

	elif "www.custom-origin-header.com" in str(data.headers) or "www.custom-origin-header.com" in str(data.content):
		resultACAO.add("Misconfigured CORS: Origin header value reflected in response headers/content")
		instance = "{}:{}".format(IP, loopPorts)

		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "CORS 'Origin' header reflected: Please check")
			missingOrInsecureHeaders.update({instance:newValue})
		
		else:
			missingOrInsecureHeaders.update({instance:"CORS 'Origin' header reflected: Please check"})

	if len(resultACAO) == 0:
		print(colored('{0:<40}'.format("Cross Origin Resource Sharing Policy:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	else:
		converted = ', '.join(resultACAO)
		print(colored('{0:<40}'.format("Cache Control:"), 'white', attrs=['bold']), colored(converted, 'red'))

	

			
def xForwardedFor(data, IP, loopPorts):

	if "X-Forwarded-For" in str(data.headers):
		
		if "100.100.100.100" in str(data.headers["X-Forwarded-For"]):
			print(colored('{0:<40}'.format("X-Forwarded-For:"), 'white', attrs=['bold']), colored("Potentially vulnerable to IP Spoofing", 'red'))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Forwarded-For: Potential IP Spoofing")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"X-Forwarded-For: Potential IP Spoofing"})

		elif "100.100.100.100" in str(data.headers)	or "100.100.100.100" in str(data.content):
			print(colored('{0:<40}'.format("X-Forwarded-For:"), 'white', attrs=['bold']), colored("Value reflected in response headers/content", 'red'))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Forwarded-For: Value reflected - Please check")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"X-Forwarded-For: Value reflected - Please check"})
	else:
		print(colored('{0:<40}'.format("X-Forwarded-For:"), 'white', attrs=['bold']), colored("Not Implemented", 'yellow'))


def csp(data, IP, loopPorts):

	if "Content-Security-Policy" in str(data.headers):
		
		if "unsafe-inline" in str(data.headers["Content-Security-Policy"]) or  "unsafe-eval" in str(data.headers["Content-Security-Policy"]):
			print(colored('{0:<40}'.format("Content-Security-Policy:"), 'white', attrs=['bold']), colored("Misconfigured", 'red'))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Content-Security-Policy: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Content-Security-Policy: Misconfigured"})

		else:
			print(colored('{0:<40}'.format("Content-Security-Policy:"), 'white', attrs=['bold']), colored("Set", 'green'))

	elif "content-security-policy" in str(data.headers):
		
		if "unsafe-inline" in str(data.headers["content-security-policy"]) or  "unsafe-eval" in str(data.headers["content-security-policy"]):
			print(colored('{0:<40}'.format("Content-Security-Policy:"), 'white', attrs=['bold']), colored("Misconfigured", 'red'))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Content-Security-Policy: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Content-Security-Policy: Misconfigured"})

		else:
			print(colored('{0:<40}'.format("Content-Security-Policy:"), 'white', attrs=['bold']), colored("Set", 'green'))
			

	else:
		print(colored('{0:<40}'.format("Content-Security-Policy:"), 'white', attrs=['bold']), colored("Not implemented", 'red'))
		instance = "{}:{}".format(IP, loopPorts)

		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Content-Security-Policy: Missing")
			missingOrInsecureHeaders.update({instance:newValue})
		
		else:
			missingOrInsecureHeaders.update({instance:"Content-Security-Policy: Missing"})


def clickjacking(data, IP, loopPorts):

	if "X-Frame-Options" in str(data.headers):
		
		if "deny" in str(data.headers["X-Frame-Options"]).lower() or "sameorigin" in str(data.headers["X-Frame-Options"]).lower() or "allow-from" in str(data.headers["X-Frame-Options"]).lower():
			
			if "*" in str(data.headers["X-Frame-Options"]).lower():
				print(colored('{0:<40}'.format("Clickjacking protection:"), 'white', attrs=['bold']), colored("Misconfigured X-Frame-Options header", 'red'))
				instance = "{}:{}".format(IP, loopPorts)

				if missingOrInsecureHeaders.get(instance):
					newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Frame-Options: Misconfigured")
					missingOrInsecureHeaders.update({instance:newValue})
				
				else:
					missingOrInsecureHeaders.update({instance:"X-Frame-Options: Misconfigured"})
			
			else:
				print(colored('{0:<40}'.format("Clickjacking protection:"), 'white', attrs=['bold']), colored("X-Frame-Options header set", 'green'))
		
		else:	 
			print(colored('{0:<40}'.format("Clickjacking protection:"), 'white', attrs=['bold']), colored("Misconfigured X-Frame-Options header", 'red'))
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Frame-Options: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"X-Frame-Options: Misconfigured"})

	elif "Content-Security-Policy" in str(data.headers):
		
		if "frame-ancestors" in str(data.headers["Content-Security-Policy"]):
			print(colored('{0:<40}'.format("Clickjacking protection:"), 'white', attrs=['bold']), colored("Content-Security-Policy Set with 'frame-ancestors' directive", 'green'))

	else:
		print(colored('{0:<40}'.format("Clickjacking protection:"), 'white', attrs=['bold']), colored("Vulnerable", 'red'))
		instance = "{}:{}".format(IP, loopPorts)

		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Frame-Options: Missing")
			missingOrInsecureHeaders.update({instance:newValue})
		
		else:
			missingOrInsecureHeaders.update({instance:"X-Frame-Options: Missing"})


def allSecurityHeaderChecks(data, IP, loopPorts, status):

	cacheControl(data, IP, loopPorts)

	originHeaderCORS(data, IP, loopPorts)

	xForwardedFor(data, IP, loopPorts)

	csp(data, IP, loopPorts)

	clickjacking(data, IP, loopPorts)

	hsts(data, IP, loopPorts, status)

	traceMethod(IP, loopPorts, status)
  

def allSecurityHeaders(IP, loopPorts, status):
	
	headers = {'Upgrade-Insecure-Requests':'1', 'Origin': 'www.custom-origin-header.com', 'X-Forwarded-For':'100.100.100.100', \
		'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
		'Accept-Encoding':'gzip, deflate',\
		'User-Agent':"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36",\
		'Connection': 'close'} 
	

	if "https" in status or "ssl" in status:
		
		SSLaddress = "https://{}:{}".format(IP, loopPorts)
		try:
			dataSSL = requests.get(SSLaddress, headers=headers, proxies=proxyDict, verify=False, allow_redirects=True, timeout=(5, 8))
			allSecurityHeaderChecks(dataSSL, IP, loopPorts, status)
		
		except Exception as e:
			  
			replace = 1
			proxyError(e, "")
			

	else:
		
		address = "http://{}:{}".format(IP, loopPorts)

		try:
			data = requests.get(address, headers=headers, proxies=proxyDict, verify=False, allow_redirects=True, timeout=(5, 8))
			allSecurityHeaderChecks(data, IP, loopPorts, status)
		
		except Exception as e:
			  
			replace = 1
			proxyError(e, "")
			


def BIGIPcookieInformationDisclosure(IP, port, status):
	
	import nmap

	argument = "-Pn -p 55553"

	nm = nmap.PortScanner()
	nm.scan('127.0.0.1', arguments=argument)

	p55553 = nm['127.0.0.1']['tcp'][55553]
	
	if p55553.get("state") == "open":
		print ("\t-> msfrpcd port open")
	else:
		print ("\t-> Starting msfrpcd on port 55553")
		os.system("msfrpcd -P toortoor")
	
	msfconsole(IP, port)

 

def socketRequestHelperMethod(IP, loopPorts, status, requestFrom):

	import socket, ssl

	if requestFrom == "iid":
		payload = "GET / HTTP/1.0\r\n\r\n"		
	elif requestFrom == "trace":
		payload = "TRACE / HTTP/1.1\r\nHost: {}\r\n\r\n".format(IP)


	if "https" in status or "ssl" in status:
		try:
			context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.settimeout(5.0)
			s_sock = context.wrap_socket(s, server_hostname=IP)
			s_sock.connect((IP , int(loopPorts)))

			s_sock.sendall(payload.encode())
			http1_0 =  s_sock.recv(8192)
			http1_0 = http1_0.decode()
			if requestFrom == "iid":
				extractIP(http1_0, IP, loopPorts, "iid")
				extractPath(http1_0, IP, loopPorts, "iid")
			elif requestFrom == "trace":
				return http1_0

		except Exception as e:
			exception = 1
			replace = 1

	else:
		try:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.settimeout(5.0)
			s.connect((IP , int(loopPorts)))
			s.sendall(payload.encode())
			http1_0 =  s.recv(8192)
			http1_0 = http1_0.decode()
			if requestFrom == "iid":
				extractIP(http1_0, IP, loopPorts, "iid")
				extractPath(http1_0, IP, loopPorts, "iid")
			elif requestFrom == "trace":
				return http1_0

		except Exception as e:
			
			exception = 1
			replace = 1


def internalIPAddressDisclosure(IP, loopPorts, status):

	socketRequestHelperMethod(IP, loopPorts, status, "iid")

  

def printVBS(resultST, resultVBS):

	if len(resultST) == 0:
		print(colored('{0:<40}'.format("Verbose Server Error:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	else:
		converted = ', '.join(resultST)
		print(colored('{0:<40}'.format("Verbose Server Error:"), 'white', attrs=['bold']), colored(converted, 'red'))

	if len(resultVBS) == 0:
		print(colored('{0:<40}'.format("Verbose Server Banner:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))

	else:
		converted = ', '.join(resultVBS)
		print(colored('{0:<40}'.format("Verbose Server Banner:"), 'white', attrs=['bold']), colored(converted, 'red'))


def verboseServerBannerCheck(data, IP, protocol, port):
	

	resultVBS = set()
	resultST = set()

	if "Server" in data.headers:
	
		if data.headers["Server"] != "":
			
			instance = "{}:{}".format(IP, port)
			banner = "Server: {}".format(data.headers["Server"])
			verboseServerBannerStore.update({instance:banner})

			resultVBS.add("Server: {}".format(str(data.headers['Server'])))
			

		if "X-AspNet-Version" in data.headers:
			if data.headers["X-AspNet-Version"] != "":

				resultVBS.add("X-AspNet-Version: {}".format(str(data.headers['X-AspNet-Version'])))
				instance = "{}:{}".format(IP, port)
				banner = "X-AspNet-Version: {}".format(data.headers["X-AspNet-Version"])
				verboseServerBannerStore.update({instance:banner})

		if "X-Powered-By" in data.headers:
			if data.headers["X-Powered-By"] != "":

				resultVBS.add("X-Powered-By: {}".format(str(data.headers['X-Powered-By'])))
				instance = "{}:{}".format(IP, port)
				banner = "X-Powered-By: {}".format(data.headers["X-Powered-By"])
				verboseServerBannerStore.update({instance:banner})

		customAddress = "http://{}/customdirectory".format(IP)
		customAddresshttps = "https://{}/customdirectory".format(IP)
		customAddress1 = "http://{}/customdirectory!@$%^&*()_+-=[]//|;':/,./><~`".format(IP)
		customAddresshttps1 = "https://{}/customdirectory!@$%^&*()_+-=[]//|;':/,./><~`".format(IP)
		customAddressUserAgent = "http://{}".format(IP)
		customAddresshttpsUserAgent = "https://{}".format(IP)

		headers = {'Host': IP, 'Upgrade-Insecure-Requests':'1', \
	'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
	'Accept-Encoding':'gzip, deflate',\
	'User-Agent':"() { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'",\
	'Connection': 'close'} 
		
		headers1 = {'Host': '<script>alert()</script>', 'Upgrade-Insecure-Requests':'1', \
	'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
	'Accept-Encoding':'gzip, deflate',\
	'User-Agent':"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36",\
	'Connection': 'close'} 

	
		data = oneRequest(None, customAddress)

		try:
			if "apache" in str((data.content)).lower() or "asp.net" in str((data.content)).lower():

				resultVBS.add("Server Banner detected in Response")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(data.request.headers)})

			if protocol == "https":
				data1 = oneRequest(None, customAddresshttps)

				if "apache" in str((data1.content)).lower() or "asp.net" in str((data1.content)).lower():

					resultVBS.add("Server Banner detected in Response")
					instance = "{}:{}".format(IP, port)
					verboseServerBannerContentStore.update({instance:str(data1.request.headers)})

			dataCustom = oneRequest(None, customAddress1)
			if "apache" in str((dataCustom.content)).lower() or "asp.net" in str((dataCustom.content)).lower():

				resultVBS.add("Server Banner detected in Response")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustom.request.headers)})

			if protocol == "https":
				dataCustom1 = oneRequest(None, customAddresshttps1)

				if "apache" in str((dataCustom1.content)).lower() or "asp.net" in str((dataCustom1.content)).lower():

					resultVBS.add("Server Banner detected in Response")
					instance = "{}:{}".format(IP, port)
					verboseServerBannerContentStore.update({instance:str(dataCustom1.request.headers)})


			dataCustomUA = oneRequest(headers, customAddressUserAgent)

			if "stack trace" in str((dataCustomUA)).lower() or "exception" in str((dataCustomUA.content)).lower() or "javax.servlet" in str((dataCustomUA.content)).lower():
				
				resultST.add("Verbose Server Error detected in Response")
				instance = "{}:{}".format(IP, port)
				payload = "Possible Stack trace, please check\n\n{}".format(dataCustomUA.request.headers)
				verboseServerErrorStore.update({instance:str(dataCustomUA.request.headers)})

			if "apache" in str((dataCustomUA)).lower() or "asp.net" in str((dataCustomUA.content)).lower():

				resultVBS.add("Server Banner detected in Response")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustomUA.request.headers)})


			dataCustomUA1 = oneRequest(headers, customAddressUserAgent)

			if "stack trace" in str((dataCustomUA1)).lower() or "exception" in str((dataCustomUA1.content)).lower() or "javax.servlet" in str((dataCustomUA1.content)).lower():

				resultST.add("Verbose Server Error detected in Response")
				instance = "{}:{}".format(IP, port)
				payload = "Possible Stack trace, please check\n\n{}".format(dataCustomUA1.request.headers)
				verboseServerErrorStore.update({instance:str(dataCustomUA1.request.headers)})

			if "apache" in str((dataCustomUA1)).lower() or "asp.net" in str((dataCustomUA1.content)).lower():

				resultVBS.add("Server Banner detected in Response")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustomUA1.request.headers)})
			

			dataCustomHost = oneRequest(headers1, customAddressUserAgent)

			if "apache" in str((dataCustomHost)).lower() or "asp.net" in str((dataCustomHost.content)).lower():

				resultVBS.add("Server Banner detected in Response")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustomHost.request.headers)})

			if protocol == "https":		
				dataCustomHost1 = oneRequest(headers1, customAddresshttpsUserAgent)

				if "apache" in str((dataCustomHost1)).lower() or "asp.net" in str((dataCustomHost1.content)).lower():

					resultVBS.add("Server Banner detected in Response")
					instance = "{}:{}".format(IP, port)
					verboseServerBannerContentStore.update({instance:str(dataCustomHost1.request.headers)})

		except Exception as e:

			proxyError(e, "")
			replace = 1

		if data.status_code != 302:
			printVBS(resultST, resultVBS)

	

def VerboseServerBanner(IP, loopPorts, status):

	headers = {'Upgrade-Insecure-Requests':'1', \
'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
'Accept-Encoding':'gzip, deflate',\
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 


	if "https" in status or "ssl" in status: 

		SSLaddress = "https://{}:{}".format(IP, loopPorts)

		try:

			dataSSL = oneRequest(headers, SSLaddress)
			
			verboseServerBannerCheck(dataSSL, IP, status, loopPorts)
			extractPath(dataSSL.content, IP, loopPorts, "vsb")
			extractPath(dataSSL.headers, IP, loopPorts, "vsb")

			if dataSSL.status_code == 302:

				redirectData = allRedirectRequests(headers, IP, loopPorts, dataSSL)

				if redirectData == None:
					errorReceived = 1
				else:

					verboseServerBannerCheck(redirectData, IP, status, loopPorts)
					extractPath(redirectData.content, IP, loopPorts, "vsb")
					extractPath(redirectData.headers, IP, loopPorts, "vsb")

		except Exception as e:
			proxyError(e, "")
			replace = 1
	
	else:
			
		address = "http://{}:{}".format(IP, loopPorts)

		try:

			data = oneRequest(headers, address)
			verboseServerBannerCheck(data, IP, "http", loopPorts)
			extractPath(data.content, IP, loopPorts, "vsb")
			extractPath(data.headers, IP, loopPorts, "vsb")

			if data.status_code == 302:

				redirectData = allRedirectRequests(headers, IP, loopPorts, data)

				if redirectData == None:
					errorReceived = 1
				else:
					verboseServerBannerCheck(redirectData, IP, status, loopPorts)
					extractPath(redirectData.content, IP, loopPorts, "vsb")
					extractPath(redirectData.headers, IP, loopPorts, "vsb")


		except Exception as e:
			replace = 1
			proxyError(e, "")
						


  
def hostHeaderInjection(IP, loopPorts, status):


	headers = {'Host': 'www.oteri.com', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	resultHHI = set()

	if "https" in status or "ssl" in status:

		addreSSL = "https://{}:{}".format(IP, loopPorts)

		try:
			injectionSSL = oneRequest(headers, addreSSL)

			if "location" in str((injectionSSL.headers)).lower():

				if "oteri" in injectionSSL.headers['Location']:
					
					resultHHI.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the location header\n\nRequest Headers:\n{}".format(str(injectionSSL.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})

				if "oteri" in str(injectionSSL.content):

					resultHHI.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the body of the response\n\nRequest Headers:\n{}".format(str(injectionSSL.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})

		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "")

	else:

		address = "http://{}:{}".format(IP, loopPorts)
		#print(address)

		try:
			injection = oneRequest(headers, address)

			if "location" in str((injection.headers)).lower():

				if "oteri" in injection.headers['Location']:
					resultHHI.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the location header\n\nRequest Headers:\n{}".format(str(injection.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})

				if "oteri" in str(injection.content):
					
					resultHHI.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the body of the response\n\nRequest Headers:\n{}".format(str(injection.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})


		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "")
			
	if len(resultHHI) == 0:
		print(colored('{0:<40}'.format("Host Header Injection:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	else:
		converted = ', '.join(resultHHI)
		print(colored('{0:<40}'.format("Host Header Injection:"), 'white', attrs=['bold']), colored(converted, 'red'))



  
def	ssrf(IP, loopPorts, status):


	headers = {'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersValid = {'Host': '8.8.8.8', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersInvalid = {'Host': '8.8.8.81', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersValidloop = {'Host': '127.0.0.1', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersInvalidloop = {'Host': '127.0.0.11', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	resultS = set()

	status1 = ""
	status2 = ""
	status3 = ""
	status4 = ""


	if "https" in status or "ssl" in status:
	

		addreSSL = "https://{}:{}".format(IP, loopPorts)

		try:
			address = "https://{}:{}/http://www.google.com".format(IP, loopPorts)
			address1 = "https://{}:{}/http://www.oteri420.com".format(IP, loopPorts)

			injectionSSL = oneRequest(headersValid, address)
			injectionSSL1 = oneRequest(headersValid, address1)
			
			test1 = injectionSSL.status_code
			test2 = injectionSSL1.status_code

			if test1 != test2:
				resultS.add("Vulnerable")
				instance = "{}:{}".format(IP, loopPorts)
				payloadLocation = "Injected in URL\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\nRequest Headers:\n{}".format(address, str(injectionSSL.request.headers), address1, str(injectionSSL1.request.headers))
				ssrfStore.update({instance:payloadLocation})

			if "Google Search" in str(injectionSSL.content) or "I'm Feeling Lucky" in str(injectionSSL.content):
				resultS.add("Vulnerable")
				instance = "{}:{}".format(IP, loopPorts)
				payloadLocation = "Injected in URL\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\nRequest Headers:\n{}".format(address, str(injectionSSL.request.headers), address1, str(injectionSSL1.request.headers))
				ssrfStore.update({instance:payloadLocation})

			
			injectionSSL2 = oneRequest(headersValid, addreSSL)
			status1 = injectionSSL2.status_code

			injectionSSL3 = oneRequest(headersInvalid, addreSSL)
			status2 = injectionSSL3.status_code
			
			injectionSSL4 = oneRequest(headersInvalidloop, addreSSL)
			status3 = injectionSSL4.status_code

			
			injectionSSL5 = oneRequest(headersInvalidloop, addreSSL)
			status4 = injectionSSL5.status_code

			resultSSRF = set((status1, status2, status3, status4))


			if len(resultSSRF) > 1:

				if status1 == status3 and status2 == status4:
				
					resultS.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Injected in the Host header\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}".format(addreSSL, str(injectionSSL2.request.headers), addreSSL, str(injectionSSL3.request.headers), addreSSL, str(injectionSSL4.request.headers), addreSSL, str(injectionSSL5.request.headers))
					ssrfStore.update({instance:payloadLocation})

		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "")


	else:

		#print(address)

		try:
			address = "http://{}:{}/http://www.google.com".format(IP, loopPorts)
			address1 = "http://{}:{}/http://www.oteri420.com".format(IP, loopPorts)

			injectionSSL = oneRequest(headersValid, address)
			injectionSSL1 = oneRequest(headersValid, address1)
			
			test1 = injectionSSL.status_code
			test2 = injectionSSL1.status_code

			if test1 != test2:
				resultS.add("Vulnerable")
				instance = "{}:{}".format(IP, loopPorts)
				payloadLocation = "Injected in URL\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\n{}\n".format(address, str(injectionSSL.request.headers), address1, str(injectionSSL1.request.headers))
				ssrfStore.update({instance:payloadLocation})

				
			address = "http://{}:{}".format(IP, loopPorts)

			injectionSSL2 = oneRequest(headersValid, address)
			status1 = injectionSSL2.status_code


			injectionSSL3 = oneRequest(headersInvalid, address)
			status2 = injectionSSL3.status_code

			injectionSSL4 = oneRequest(headersValidloop, address)
			status3 = injectionSSL4.status_code


			injectionSSL5 = oneRequest(headersInvalidloop, address)
			status4 = injectionSSL5.status_code


			resultSSRF = set((status1, status2, status3, status4))

			if len(resultSSRF) > 1:
				
				if status1 == status3 and status2 == status4:
					
					resultS.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Injected in the Host header\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}".format(address, str(injectionSSL2.request.headers), address, str(injectionSSL3.request.headers), address, str(injectionSSL4.request.headers), address, str(injectionSSL5.request.headers))
					ssrfStore.update({instance:payloadLocation})


		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "")
			

	resultSSRF = set()

	if len(resultS) == 0:
		print(colored('{0:<40}'.format("Server Side Request Forgery:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	else:
		converted = ', '.join(resultS)
		print(colored('{0:<40}'.format("Server Side Request Forgery:"), 'white', attrs=['bold']), colored(converted, 'red'))





def worksheetFill():

	worksheet.set_default_row(25)
	worksheetWeb.set_default_row(25)


	row = 2
	col = 0
	for key,value in expiredCerts.items():
		worksheet.write(row, col, key, cell_format)
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format) 
		worksheet.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 3
	for key,value in soonToExpireCerts.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 6
	for key,value in anonCiphersStore.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 9
	for key,value in httpsNotEnabled.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 12
	for key,value in httpsNotEnforced.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 15
	for key,value in HSTSMisconfig.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 18
	for key,value in SSL2.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 19
	for key,value in SSL3.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 20
	for key,value in TLS1.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 0
	for key,value in verboseServerBannerStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 3
	for key,value in verboseServerBannerContentStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 6
	for key,value in hostHeaderInjectionStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 9
	for key,value in internalIPDisclosureStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 12
	for key,value in bigIPDisclosureStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 15
	for key,value in ssrfStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 18
	for key,value in verboseServerErrorStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 21
	for key,value in extractPathStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 24
	for key,value in missingOrInsecureHeaders.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 27
	for key,value in traceEnabled.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		row +=1

	row = 2
	col = 0
	for key,value in ntpStore.items():
		worksheetNetwork.write(row, col, key, cell_format) 
		worksheetNetwork.set_column(row, col, 25)
		worksheetNetwork.write(row, col+1, value, cell_format) 
		worksheetNetwork.set_column(row, col+1, 25)
		row +=1
		
	row = 2
	col = 3
	for key,value in dnsDOSStore.items():
		worksheetNetwork.write(row, col, key, cell_format) 
		worksheetNetwork.set_column(row, col, 25)
		worksheetNetwork.write(row, col+1, value, cell_format) 
		worksheetNetwork.set_column(row, col+1, 25)
		row +=1


def enumerate(IP, port, status, args):

	cprint ("\n[*] SSL/TLS Check\n", 'white', attrs=['bold','underline'])
	ssl(IP, port, status)
	cprint ("\n[*] Web Application Vulnerability Check\n", 'white', attrs=['bold','underline'])
	VerboseServerBanner(IP, port, status)
	hostHeaderInjection(IP, port, status)
	allSecurityHeaders(IP, port, status)
	internalIPAddressDisclosure(IP, port, status)
	ssrf(IP, port, status)
	cprint ("\n[*] Network Vulnerability Check\n", 'white', attrs=['bold','underline'])
	ntpMode6(IP)
	
	if IP in dnsPortCheck:
		dnsDOS(IP)
		dnsCacheSnooping(IP)
	else:
  		print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("DNS Port closed", 'yellow'))


def nmap(IP):
	port = args.port 
	start1=time.time()
	import nmap

	if port:
		port = str(port)
	else:
		port=""
	argument = "-Pn -p80,443,8443,8080,53,{}".format(port)

	try:
		nm = nmap.PortScanner()
		nm.scan(IP, arguments=argument)

		
		p80 = nm[IP]['tcp'][80]
		#print(nm[IP]['tcp'][443])
		p443 = nm[IP]['tcp'][443]
		#print(nm[IP]['tcp'][8080])
		p8080 = nm[IP]['tcp'][8080]
		#print(nm[IP]['tcp'][8443])
		p8443 = nm[IP]['tcp'][8443]

		p53 = nm[IP]['tcp'][53]

		if p53.get("state") == "open":
			dnsPortCheck.add(IP)
			
		if p80.get("state") == "open":
			storeData = "{}:{}".format(p80.get("name"),"80")
			if storeOpenPorts.get(IP):
				newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
				storeOpenPorts.update({IP:newValue})

			else:
				storeOpenPorts.update({IP:storeData})

		if p443.get("state") == "open":
			storeData = "{}:{}".format(p443.get("name"),"443")
			if storeOpenPorts.get(IP):
				newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
				storeOpenPorts.update({IP:newValue})

			else:
				storeOpenPorts.update({IP:storeData})

		if p8080.get("state") == "open":
			storeData = "{}:{}".format(p8080.get("name"),"8080")
			if storeOpenPorts.get(IP):
				newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
				storeOpenPorts.update({IP:newValue})

			else:
				storeOpenPorts.update({IP:storeData})

		if p8443.get("state") == "open":
			storeData = "{}:{}".format(p8443.get("name"),"8443")
			if storeOpenPorts.get(IP):
				newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
				storeOpenPorts.update({IP:newValue})

			else:
				storeOpenPorts.update({IP:storeData})

	except Exception as e:
		print(e)
		replace = 1


	if port.strip() != "":
		
		if "," in port:
			port = port.split(",")
			#print(port)

			for i in port:
				pCustom = ""
				pCustom = nm[IP]['tcp'][int(i)]

				if pCustom.get("state") == "open":
					storeData = "{}:{}".format(pCustom.get("name"),i)
					if storeOpenPorts.get(IP):
						newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
						storeOpenPorts.update({IP:newValue})

					else:
						storeOpenPorts.update({IP:storeData})

		else:
			pCustom = ""
			pCustom = nm[IP]['tcp'][int(port)]
			if pCustom.get("state") == "open":
				storeData = "{}:{}".format(pCustom.get("name"),port)
				if storeOpenPorts.get(IP):
					newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
					storeOpenPorts.update({IP:newValue})

				else:
					storeOpenPorts.update({IP:storeData})



	end1 = time.time()
	#print("\nTotal Runtime of nmap: ")
	#print(end1 - start1)

  
def startScan(args, ip):
	

	listOfPorts = {}

	port = storeOpenPorts.get(ip)
	
	port = port.split(",")
	
	for i in port:
		port = i.split(":")
		listOfPorts.update({port[1]:port[0]})


	ip = str(ip)
	for port, status in listOfPorts.items():

		cprint ("\n\nScanning: {}:{}".format(ip,port), 'yellow')

		if args.f:
			
			enumerate(ip, port, status, args)

		else:
			cprint ("\n[*] Custom Vulnerability Check\n", 'white', attrs=['bold','underline'])
			if args.m:
				allSecurityHeaders(ip, port, status)
			if args.hi:
				hostHeaderInjection(ip, port, status)
			if args.v:			
				VerboseServerBanner(ip, port, status)
			if args.big:
				BIGIPcookieInformationDisclosure(ip, port, status)
			if args.i:
				internalIPAddressDisclosure(ip, port, status)
			if args.ssl:
				ssl(ip, port, status)
			if args.ssrf:
				ssrf(ip, port, status)
			if args.ntp:
				ntpMode6(ip)
			if args.dns:

				if ip in dnsPortCheck:
					dnsDOS(ip)
					dnsCacheSnooping(ip)
				else:
			  		print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("DNS Port closed\n", 'yellow'))

  
def arguments(args):

	global proxyDict

	if args.proxy:
		
		proxyValHttp = "http://{}".format(args.proxy)
		proxyValHttps = "https://{}".format(args.proxy)

		proxyDict = { 
          "http"  : proxyValHttp, 
          "https" : proxyValHttps
        	}

		try:
			address = "https://www.google.com"
			proxyCheck = oneRequest(None, address)
		except Exception as e:
			replace = 1
			proxyError(e, "scan")
			
	else:
		proxyDict = {}

	ipStore = []
	with open(args.filename) as f:
			
		for ip in f:
			ip = ip.strip()

			if ip == "":
				continue
			else:
				ipStore.append(ip)
	
	print (colored("\n\n<--", 'red', attrs=['bold']), colored(" Port Scan in Progress ", 'green', attrs=['bold']), colored("-->", 'red', attrs=['bold']))
	with concurrent.futures.ThreadPoolExecutor(max_workers=10) as ello:
		ello.map(nmap, ipStore)
	
	for ips in storeOpenPorts:
		startScan(args, ips)



if len(sys.argv) < 3:

	sys.argv.append('--help')

parser = argparse.ArgumentParser()
parser.add_argument('filename', help="file path with ip addresses to scan")
parser.add_argument('-port', help='scan custom port, use comma-seperated values for multiple ports')
parser.add_argument('-proxy', help='use an intercepting proxy, provide IP and Port number. eg. -proxy 127.0.0.1:8080')
parser.add_argument('-big', help='check if BIGIP cookie is present and whether it is vulnerable to information disclosure',  action="store_true")
parser.add_argument('-f', help='scan for all options given below',  action="store_true")
parser.add_argument('-m', help='check for any misconfigurations or missing security headers',  action="store_true")
parser.add_argument('-hi', help='check if application is vulnerable to Host Header Injection',  action="store_true")
parser.add_argument('-v', help='check if the application returns a verbose server banner',  action="store_true")
parser.add_argument('-i', help='check if the application discloses internal ip addresses',  action="store_true")
parser.add_argument('-ssl', help="check if there are ssl related vulnerabilities or misconfigurations",   action="store_true")
parser.add_argument('-ssrf', help="response based detection for server side request forgery",   action="store_true")
parser.add_argument('-ntp', help='check if the remote NTP server responds to mode 6 queries (DOS)',  action="store_true")
parser.add_argument('-dns', help='check if the remote DNS server responds with a large amplification factor (DOS)',  action="store_true")

global args
args = parser.parse_args()

arguments(args)
worksheetFill()
workbook.close() 
ipList = set()

end = time.time()
cprint("\nTotal Runtime of Script: ", 'yellow', attrs=['bold'])
cprint(end - start, 'white',attrs=['bold'])
os.system("stty sane")