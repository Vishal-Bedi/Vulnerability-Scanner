import sys
import subprocess
import os
from requests import Session, Request
import re
import urllib3
import argparse
from pymetasploit3.msfrpc import MsfRpcClient
import socket
from OpenSSL import SSL
from cryptography import x509
from cryptography.x509.oid import NameOID
import idna
from socket import socket
from collections import namedtuple
import concurrent.futures
import requests

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


#BIGIP timeout 
#Store Searchsploit Results
#Store the request made during testing if its a positive
#Implement Dictionary instead of set
#BIGIP grep for port
#ssl check https://gist.github.com/gdamjan/55a8b9eec6cf7b771f92021d93b87b2c

ipList = set()
storeOpenPorts = {}

def ssl(IP, port):

	HostInfo = namedtuple(field_names='cert hostname peername', typename='HostInfo')

	for loopPorts in port:
		#print(port.get(loopPorts))
		if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
			
			HOSTS = [(IP, int(loopPorts))]

			try:
				def verify_cert(cert, hostname):
			    	# verify notAfter/notBefore, CA trusted, servername/sni/hostname
					cert.has_expired()
			    	# service_identity.pyopenssl.verify_hostname(client_ssl, hostname)
			    	# issuer

				def get_certificate(hostname, port):
				    hostname_idna = idna.encode(hostname)
				    sock = socket()

				    sock.connect((hostname, port))
				    peername = sock.getpeername()
				    ctx = SSL.Context(SSL.SSLv23_METHOD) # most compatible
				    ctx.check_hostname = False
				    ctx.verify_mode = SSL.VERIFY_NONE

				    sock_ssl = SSL.Connection(ctx, sock)
				    sock_ssl.set_connect_state()
				    sock_ssl.set_tlsext_host_name(hostname_idna)
				    sock_ssl.do_handshake()
				    cert = sock_ssl.get_peer_certificate()
				    crypto_cert = cert.to_cryptography()
				    sock_ssl.close()
				    sock.close()

				    return HostInfo(cert=crypto_cert, peername=peername, hostname=hostname)

				def get_alt_names(cert):
				    try:
				        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName)
				        return ext.value.get_values_for_type(x509.DNSName)
				    except x509.ExtensionNotFound:
				        return None

				def get_common_name(cert):
				    try:
				        names = cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)
				        return names[0].value
				    except x509.ExtensionNotFound:
				        return None

				def get_issuer(cert):
				    try:
				        names = cert.issuer.get_attributes_for_oid(NameOID.COMMON_NAME)
				        return names[0].value
				    except x509.ExtensionNotFound:
				        return None


				def print_basic_info(hostinfo):
				    s = '''\n» {hostname} « … {peername}
				    \tcommonName: {commonname}
				    \tSAN: {SAN}
				    \tissuer: {issuer}
				    \tnotBefore: {notbefore}
				    \tnotAfter:  {notafter}
				    '''.format(
				            hostname=hostinfo.hostname,
				            peername=hostinfo.peername,
				            commonname=get_common_name(hostinfo.cert),
				            SAN=get_alt_names(hostinfo.cert),
				            issuer=get_issuer(hostinfo.cert),
				            notbefore=hostinfo.cert.not_valid_before,
				            notafter=hostinfo.cert.not_valid_after
				    )
				    print(s)

				def check_it_out(hostname, port):
				    hostinfo = get_certificate(hostname, port)
				    print_basic_info(hostinfo)


				with concurrent.futures.ThreadPoolExecutor(max_workers=4) as e:
					for hostinfo in e.map(lambda x: get_certificate(x[0], x[1]), HOSTS):
						print_basic_info(hostinfo)
			except:
				count = "buff!"

					
def portOpenCheck(IP, port):

	try:
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		result = sock.connect_ex((IP,int(port)))

	except:
		return False 
 

	if result == 0:
		return True
	else:
		return False

	sock.close()


def httpRequests():
	print ("placeholder")

def httpsRequests():
	print ("placeholder")


def extractIP(extractIPFromString):

	regex = (re.findall( r'(?:[\d]{1,3})\.(?:[\d]{1,3})\.(?:[\d]{1,3})\.(?:[\d]{1,3})', str(extractIPFromString)))
	
	for ip in regex:

		if ip.startswith("10.") or ip.startswith("192.168."):
			print ("	-> Internal IP Found")
			ipList.add(ip)
			print (ip)
		elif ip.startswith("172.") and int(ip.split(".")[1]) >= 16 and int(ip.split(".")[1]) <= 31:
			print ("	-> Internal IP Found")
			print (ip)
			ipList.add(ip)
	return ipList


def msfconsole(IP, port):
	
	print("before")
	client = MsfRpcClient('toortoor', port=55553, ssl=True)
	print("after")
	exploit = client.modules.use('auxiliary','gather/f5_bigip_cookie_disclosure')
	exploit['RHOSTS'] = IP
	exploit['RPORT'] = int(port)
	exploit['SSL']= False
	try:
		console_id = client.consoles.console().cid
		console = client.consoles.console(console_id)
		extractIP(console.run_module_with_output(exploit))

	except:
		print ("Connection failed")


def BIGIPcookieInformationDisclosure(IP, port):

	print ("\n[*] BIGIP Cookie Information Disclosure Check")
#	IP = "199.255.140.183"
	
	import nmap

	argument = "-Pn -p 55553"

	nm = nmap.PortScanner()
	nm.scan('127.0.0.1', arguments=argument)
	print(nm['127.0.0.1']['tcp'][55553])
	p55553 = nm['127.0.0.1']['tcp'][55553]
	
	if p55553.get("state") == "open":
		print ("	-> msfrpcd port open")
	else:
		print ("	-> Starting msfrpcd on port 55553")
		os.system("msfrpcd -P toortoor")

	for loopPorts in port:
		msfconsole(IP, loopPorts)


def internalIPAddressDisclosure(IP, port):
	
#	IP = "193.240.139.19"     
	print ("\n[*] Internal  IP  Disclosure Check")

	for loopPorts in port:
		print(port.get(loopPorts))
		if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
	
			curlHeader = "curl --http1.0  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent > headers"
			curlContent = "curl --http1.0  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent > content"	
			curlHeader1 = "curl --http1.1  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent > headers1"
			curlContent1 = "curl --http1.1  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent > content1"	

		else:

			curlHeader = "curl --http1.0  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent > headers"
			curlContent = "curl --http1.0  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent > content"	
			curlHeader1 = "curl --http1.1  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent > headers1"
			curlContent1 = "curl --http1.1  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent > content1"	


		try:
			os.system(curlHeader)

			HeaderFileName = "./headers"
			with open(HeaderFileName) as f:
				for line in f:
					found = extractIP(line)

			os.system(curlContent)

			ContentFileName = "./content"
			with open(HeaderFileName) as f:
				for line in f:
					found = extractIP(line)

			os.system(curlHeader1)

			HeaderFileName = "./headers1"
			with open(HeaderFileName) as f:
				for line in f:
					found = extractIP(line)

			os.system(curlContent1)

			ContentFileName = "./content1"
			with open(HeaderFileName) as f:
				for line in f:
					found = extractIP(line)


		except:
			print ("	-> Error while attempting IP Disclosure: "+IP)

		
	print ("	-> IP Disclosure Attempt Completed")


def hstsCheck(data):
		
	if 'strict-transport-security' not in data.headers:
		print("	-> HSTS Header Missing")
	else:
		values = data.headers['strict-transport-security']
		max_age = int("".join(filter(str.isdigit, values)))
		
		if 'max-age' not in data.headers['strict-transport-security'] or max_age < 10886400:
			print ("	-> HSTS not implemented properly: max-age should be at least eighteen weeks")
		else:
			print ("	-> HSTS implemented correctly")


def hsts(IP, port):

	print ("\n[*] Strict Transport Security Header Check")
#	IP = "173.226.65.7"

	ssladdress = "https://"+str(IP)

	for loopPorts in port:
		print(port.get(loopPorts))
		if "https" or "ssl" in port.get(loopPorts):
			ssladdress = "https://"+str(IP)+":"+loopPorts

			try:
				dataSSL = requests.get(ssladdress, verify=False, timeout=(5, 14))
				#if dataSSL.status_code == 200 or dataSSL.status_code == 403 or dataSSL.status_code == 404:
				hstsCheck(dataSSL)
				#else:
				#	return

			except requests.exceptions.RequestException as e:
				exception = 1

		
def verboseServerBannerCheck(data, IP, protocol):
	
	if "Server" in data.headers:
		
		if data.headers["Server"] != "":
			print ("Verbose Server Banner: "+protocol)

			if "apache" in  str(data.headers['Server']).lower():
				print("Apache server")
				if "/" in data.headers['Server']:
					splitValue = data.headers['Server'].split('/')
					output = subprocess.check_output(['searchsploit',splitValue[0],splitValue[1]])

				else:
					output = subprocess.check_output(['searchsploit',data.headers['Server']])


			elif "iis" in  str((data.headers['Server'])).lower():
				print("IIS server")

				if "/" in data.headers['Server']:
					splitValue = data.headers['Server'].split('/')
					subprocess.check_output(['searchsploit',splitValue[0],splitValue[1]])
				else:
					output = subprocess.check_output(['searchsploit',data.headers['Server']])
					

			else:
				if "/" in data.headers['Server']:
					splitValue = data.headers['Server'].split('/')
					subprocess.check_output(['searchsploit',splitValue[0],splitValue[1]])
				print("Other Server")
				output = subprocess.check_output(['searchsploit',data.headers['Server']])
				

		if "X-AspNet-Version" in data.headers:
			if data.headers["X-AspNet-Version"] != "":
				print("Verbose Software Version: "+protocol)

		if "X-Powered-By" in data.headers:
			if data.headers["X-Powered-By"] != "":
				print("Verbose Server Banner: "+protocol) 

		customAddress = "http://"+IP+"/customdirectory"
		customAddresshttps = "https://"+IP+"/customdirectory"

		try:
			data = requests.get(customAddress, verify=False, timeout=(5, 14))
			data1 = requests.get(customAddresshttps, verify=False, timeout=(5, 14))
			if "apache" in str((data.content)).lower() or "asp.net" in str((data.content)).lower():
				print ("Verbose Server Banner in content")
		
			if "apache" in str((data1.content)).lower() or "asp.net" in str((data1.content)).lower():
				print ("Verbose Server Banner in content")

		except requests.exceptions.RequestException as e:
			exception = 1
		
		


def VerboseServerBanner(IP, port):

	print ("\n[*] Verbose Server Banner Check")
#	IP = "173.226.65.7"
	headers = {'Host': IP, 'Upgrade-Insecure-Requests':'1', \
'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
'Accept-Encoding':'gzip, deflate',\
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 
	proxyDict = { 
              "http"  : "http://127.0.0.1:8080", 
              "https" : "https://127.0.0.1:8080"
            }
	for loopPorts in port:
		
		if int(loopPorts) != 443 and int(loopPorts) != 80:

			if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
				
				SSLaddress = "https://"+str(IP)+":"+loopPorts

				try:
					print(port.get(loopPorts))
					dataSSL = requests.get(SSLaddress, headers=headers, verify=False, proxies=proxyDict, timeout=(30, 34))
					print(dataSSL.headers)
				#if dataSSL.status_code == 200 or dataSSL.status_code == 403 or dataSSL.status_code == 404:
					verboseServerBannerCheck(dataSSL, IP, "https")
				#else:
			#	return
				except requests.exceptions.Timeout:
					continue
			
			else:
				print("OK")


		elif "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
			
			SSLaddress = "https://"+str(IP)

			try:
				dataSSL = requests.get(SSLaddress, headers=headers, verify=False,proxies=proxyDict, timeout=(30, 34))
				print(dataSSL.headers)
			#if dataSSL.status_code == 200 or dataSSL.status_code == 403 or dataSSL.status_code == 404:
				verboseServerBannerCheck(dataSSL, IP, "https")
			#else:
			#	return

			except requests.exceptions.Timeout:
				continue
			
		else:
			address = "http://"+str(IP)+":"+loopPorts

			try:
				data = requests.get(address, headers=headers, verify=False,proxies=proxyDict, timeout=(30, 34))
				print(data.headers)
			#if data.status_code == 200 or data.status_code == 403 or data.status_code == 404:
				verboseServerBannerCheck(data, IP, "http")
			
		#else:
				#	return
			except requests.exceptions.Timeout:
				continue
	

def hostHeaderInjection(IP, port):

	print ("\n[*] Host Header Injection Check")
#	IP = "173.226.65.7"	

	headers = {'Host': 'www.oteri.com', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	for loopPorts in port:
		print(port.get(loopPorts))
		if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
			if int(loopPorts) != 443 and int(loopPorts) != 80:

				addreSSL = "https://"+str(IP)+":"+loopPorts

				try:
					injectionSSL = requests.get(addreSSL, verify=False, headers=headers, allow_redirects=False, timeout=(5, 14))
				
					if "location" in str((injectionSSL.headers)).lower():

						if "oteri" in injectionSSL.headers['Location']:
							print ("	-> Host Header Injection Successful")

						if "oteri" in str(injectionSSL.content):
							print("	-> Host header value reflected in body")

				except requests.exceptions.RequestException as e:
					exception = 1


		elif "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):

			addreSSL = "https://"+str(IP)

			try:
				injectionSSL = requests.get(addreSSL, verify=False, headers=headers, allow_redirects=False, timeout=(5, 14))
			
				if "location" in str((injectionSSL.headers)).lower():

					if "oteri" in injectionSSL.headers['Location']:
						print ("	-> Host Header Injection Successful")

					if "oteri" in str(injectionSSL.content):
						print("	-> Host header value reflected in body")

			except requests.exceptions.RequestException as e:
				exception = 1



		else:

			address = "http://"+str(IP)+":"+loopPorts
			print(address)

			try:
				injection = requests.get(address, verify=False, headers=headers, allow_redirects=False, timeout=(5, 14))
			
				if "location" in str((injection.headers)).lower():

					if "oteri" in injection.headers['Location']:
						print ("	-> Host Header Injection Successful")

					if "oteri" in str(injection.content):
						print("	-> Host header value reflected in body")

			except requests.exceptions.RequestException as e:
				exception = 1



def enumerate(IP, port):

	ssl(IP, port)
	VerboseServerBanner(IP, port)
	hostHeaderInjection(IP, port)
	hsts(IP,port)
	internalIPAddressDisclosure(IP, port)
	BIGIPcookieInformationDisclosure(IP, port)
	

def nmap(IP, port):

	import nmap

	argument = "-Pn -p80,443,8443,8080,"+str(port)

	nm = nmap.PortScanner()
	nm.scan(IP, arguments=argument)

	#print(nm[IP]['tcp'][80])
	p80 = nm[IP]['tcp'][80]
	#print(nm[IP]['tcp'][443])
	p443 = nm[IP]['tcp'][443]
	#print(nm[IP]['tcp'][8080])
	p8080 = nm[IP]['tcp'][8080]
	#print(nm[IP]['tcp'][8443])
	p8443 = nm[IP]['tcp'][8443]

	if p80.get("state") == "open":
		storeOpenPorts.update({"80":p80.get("name")})

	if p443.get("state") == "open":
		storeOpenPorts.update({"443":p443.get("name")})

	if p8080.get("state") == "open":
		storeOpenPorts.update({"8080":p8080.get("name")})

	if p8443.get("state") == "open":
		storeOpenPorts.update({"8443":p8443.get("name")})


	if port.strip() != "":
		
		if "," in port:
			port = port.split(",")
			#print(port)

			for i in port:
				pCustom = ""
				pCustom = nm[IP]['tcp'][int(i)]

				if pCustom.get("state") == "open":
					storeOpenPorts.update({i:pCustom.get("name")})

		else:
			pCustom = ""
			pCustom = nm[IP]['tcp'][int(port)]
			if pCustom.get("state") == "open":
				storeOpenPorts.update({port:pCustom.get("name")})


	#print(storeOpenPorts)
	return storeOpenPorts


def arguments(args):

	with open(args.filename) as f:
		for ip in f:
			ip = ip.strip()

			if ip == "":
				continue
			else:
				print ("\nScanning: "+ip)
				global storeOpenPorts
				storeOpenPorts = {}
				if args.port:
					openPorts = nmap(ip, args.port)
				else:
					port=""
					openPorts = nmap(ip, port)

			#print(openPorts)

			if args.full:

				enumerate(ip, openPorts)

			else:
				port = ""
				if args.hsts:
					hsts(ip, openPorts)
				if args.hhi:
					hostHeaderInjection(ip, openPorts)
				if args.vsb:
					VerboseServerBanner(ip, openPorts)
				if args.bigip:
					BIGIPcookieInformationDisclosure(ip, openPorts)
				if args.iid:
					internalIPAddressDisclosure(ip, openPorts)
				if args.ssl:
					ssl(ip, openPorts)



if len(sys.argv) < 2:
	sys.argv.append('--help')
	
parser = argparse.ArgumentParser()
parser.add_argument('filename', help="file path with ip addresses to scan")
parser.add_argument('--port', help='scan custom port, use comma-seperated values for multiple ports')
parser.add_argument('--full', help='scan for all options given below',  action="store_true")
parser.add_argument('--hsts', help='check if the "strict-transport-security" header is present',  action="store_true")
parser.add_argument('--hhi', help='check if application is vulnerable to Host Header Injection',  action="store_true")
parser.add_argument('--vsb', help='check if the application returns a verbose server banner',  action="store_true")
parser.add_argument('--bigip', help='check if BIGIP cookie is present and whether it is vulnerable to information disclosure',  action="store_true")
parser.add_argument('--iid', help='check if the application discloses internal ip addresses',  action="store_true")
parser.add_argument('--ssl', help="check if the server's certificate is valid",   action="store_true")


args = parser.parse_args()

arguments(args)
'''
IPAddressFile = sys.argv[1]

with open(IPAddressFile) as file:
	for IP in file:
		print ("IP")
		enumerate(IP)

'''

#hostHeaderInjection()
#hsts()
#VerboseServerBanner()
#internalIPAddressDisclosure()
#BIGIPcookieInformationDisclosure()

'''			allPortsToScan = ""
			count = 0

			for i in openPorts:
				allPortsToScan += i
				if count == len(openPorts)-1:
					break		
				allPortsToScan += ","
			print(allPortsToScan)

			if args.port:
				if args.full:
					enumerate(ip, args.port)
				else:
					if args.hsts:
						hsts(ip, args.port)
					if args.hhi:
						hostHeaderInjection(ip, args.port)
					if args.vsb:
						VerboseServerBanner(ip, args.port)
					if args.bigip:
						BIGIPcookieInformationDisclosure(ip, args.port)
					if args.iid:
						internalIPAddressDisclosure(ip, args.port)
'''			
