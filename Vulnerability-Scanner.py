import sys
import subprocess
import os
from requests import Session, Request
import re
import urllib3
import argparse
from pymetasploit3.msfrpc import MsfRpcClient
import socket
from OpenSSL import SSL
from service_identity import VerificationError
from cryptography import x509
from cryptography.x509.oid import NameOID
import idna
import signal
from collections import namedtuple
import concurrent.futures
import requests
import threading
import queue
from datetime import datetime, timedelta
import time
import xlsxwriter
from random import randrange
from scapy.all import *
from socket import socket

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

#sweet32, logjam, beast
#CORS origin header reflect
#HTTP Trace enabled
#BIGIP timeout 
#BIGIP grep for port
#Resume Function
#ssl check https://gist.github.com/gdamjan/55a8b9eec6cf7b771f92021d93b87b2c

start=time.time()

ipList = set()
expiredCerts = {}
anonCiphersStore = {}
httpsNotEnforced = {}
httpsNotEnabled = {}
verboseServerBannerContentStore = {}
verboseServerBannerStore = {}
hostHeaderInjectionStore = {}
HSTSMisconfig = {}
internalIPDisclosureStore = {}
bigIPDisclosureStore = {}
ssrfStore = {} 
verboseServerErrorStore = {}
extractPathStore = {}
TLS1 = {}
SSL3 = {}
SSL2 = {}
ntpStore = {}

workbook = xlsxwriter.Workbook('Vulnerability_Results.xlsx') 
bold = workbook.add_format({'bold': True})
cell_format = workbook.add_format()
cell_format.set_text_wrap()
worksheet = workbook.add_worksheet("SSL Vulnerabilities") 
worksheetWeb = workbook.add_worksheet("Web Vulnerabilities") 
worksheetNetwork = workbook.add_worksheet("Network Vulnerabilities") 
worksheet.write(0, 0, "Certificate Expired", bold)
worksheet.write(0, 1, "All information", bold)
worksheet.write(0, 4, "Anonymous SSL/TLS ciphers supported", bold)
worksheet.write(0, 5, "All information", bold)
worksheet.write(0, 8, "HTTPS Not Enabled", bold)
worksheet.write(0, 9, "All information", bold)
worksheet.write(0, 12, "HTTPS Not Enforced", bold)
worksheet.write(0, 13, "All information", bold)
worksheet.write(0, 16, "HSTS Missing or Misconfigured", bold)
worksheet.write(0, 17, "All information", bold)
worksheet.write(0, 20, "SSLv2 Enabled", bold)
worksheet.write(0, 21, "SSLv3 Enabled", bold)
worksheet.write(0, 22, "TLSv1.0 Enabled", bold)

worksheetWeb.write(0, 0, "Verbose Server Banner", bold)
worksheetWeb.write(0, 1, "Disclosed Header", bold)
worksheetWeb.write(0, 4, "Verbose Server Banner in Response", bold)
worksheetWeb.write(0, 5, "Request Headers", bold)
worksheetWeb.write(0, 8, "Host Header Injection", bold)
worksheetWeb.write(0, 9, "Request Headers", bold)
worksheetWeb.write(0, 12, "Internal IP Disclosure", bold)
worksheetWeb.write(0, 13, "Disclosed IP Address", bold)
worksheetWeb.write(0, 16, "BigIP Cookie Internal IP Disclosure", bold)
worksheetWeb.write(0, 17, "Disclosed IP Address", bold)
worksheetWeb.write(0, 20, "Server Side Request Forgery", bold)
worksheetWeb.write(0, 21, "Vulnerable parameter", bold)
worksheetWeb.write(0, 24, "Verbose Server Error", bold)
worksheetWeb.write(0, 25, "Exception", bold)
worksheetWeb.write(0, 28, "Internal Path Disclosure", bold)
worksheetWeb.write(0, 29, "Exception", bold)

worksheetNetwork.write(0, 0, "Network Time Protocol (NTP) Mode 6 Scanner", bold)
worksheetNetwork.write(0, 1, "Response", bold)

def proxyError(e, method):

	
	if "Cannot connect to proxy" in str(e):
		
		if method == "scan":
			print("\nCannot connect to proxy\n\nPlease enable proxy to continue scanning\n")
			sys.exit()

		else:	
			address = "https://www.google.com"
		
			while True:
				try:
					proxyCheck = requests.get(address, verify=False, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
					
					if proxyCheck.status_code:
						break
					else:
						
						time.sleep(2)
						continue

				except Exception as e:

					if "Cannot connect to proxy" in str(e):
						
						time.sleep(2)
						continue
					else:
						break
			return

	else:		
		return


def ntpMode6(IPAddress):

	ntpserver = IPAddress
	data = "\x16\x02\x00\x01" + "\x00" * 8
	
	packets = IP(dst=ntpserver)/UDP(sport=48947,dport=123)/Raw(load=data) 
	send(packets, verbose=0)
	resultNTP = sniff(iface="eth0",timeout = 2)

	try:
		for i in range (0,9):
					
			if "processor" in str(resultNTP[i]) and "rootdelay" in str(resultNTP[i]):
				print("\t-> NTP Server replied to Mode 6 queries. Potential to be used in NTP amplification attacks")
				instance = str(IPAddress) + ":123u"
				ntpStore.update({instance:str(resultNTP[i])})
				break

	except Exception as e:
			return



def anonCiphers(IP, port):

	try:
		import nmap
		
		argument = "-Pn -sV --script ssl-enum-ciphers -p"+str(port)

		nm = nmap.PortScanner()
		nm.scan(IP, arguments=argument)

		storeResult = nm[IP]['tcp'][int(port)]

		#Print nmap result Dictionary
		#print(storeResult.get('script', {}).get('ssl-enum-ciphers'))

		storeResult = storeResult.get('script', {}).get('ssl-enum-ciphers')
		#print(nm[IP]['tcp'][int(port)])


		if "SSLv2:" in storeResult:
				instance = str(IP) + ":" + str(port)
				SSL2.update({instance:str(storeResult)})

		if "SSLv3:" in storeResult:
				instance = str(IP) + ":" + str(port)
				SSL3.update({instance:str(storeResult)})

		if "TLSv1.0:" in storeResult:
				instance = str(IP) + ":" + str(port)
				TLS1.update({instance:str(storeResult)})

		if "least strength:" in storeResult:

			if "least strength: A" in storeResult or "least strength: B" in storeResult :
				print("\t-> Anonymous SSL/TLS Ciphers not Enabled")
			else:
				print("\t-> Anonymous SSL/TLS Ciphers Enabled")
				instance = str(IP) + ":" + str(port)
				anonCiphersStore.update({instance:str(storeResult)})
		else:
			return
	except:
		return


def httpsEnforced(IP, port):

	headers = {'Host': 'www.oteri.com', 'Upgrade-Insecure-Requests':'1', \
	'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
	'Connection': 'close'} 
	#print(IP, port)
	address = "http://"+str(IP)+":"+port
	
	try:
		SSLcon = requests.get(address, verify=False, headers=headers, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
		
		if "location" in str((SSLcon.headers)).lower():

			if "https" in SSLcon.headers['Location']:
				print ("\t-> HTTPS Enforced")

			else:
				enabled = 1
				try:
					addreSSL = "https://"+str(IP)+":"+port
					SSLcon = requests.get(addreSSL, verify=False, proxies=proxyDict, headers=headers, allow_redirects=False, timeout=(5, 14))			
				except:	
					enabled = 0
					print("\t-> HTTPS not Enabled")
					instance = str(IP) + ":" + str(port)
					httpsNotEnabled.update({instance:"Disabled"})
				
				if enabled == 1:
					print("\t-> HTTPS not Enforced")
					instance = str(IP) + ":" + str(port)
					httpsNotEnforced.update({instance:"Enabled"})

	except requests.exceptions.RequestException as e:
		exception = 1
		proxyError(e, "")
		


def ssl(IP, port):

	print ("\n[*] SSL/TLS Check")
	HostInfo = namedtuple(field_names='cert hostname peername', typename='HostInfo')

	for loopPorts in port:

		#print(port.get(loopPorts))
		if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
			
			HOSTS = [(IP, int(loopPorts))]
			
		
			try:
				def get_certificate(hostname, port):

				    hostname_idna = idna.encode(hostname)
				    sock = socket()

				    sock.connect((hostname, port))
				    peername = sock.getpeername()
				    ctx = SSL.Context(SSL.SSLv23_METHOD) # most compatible
				    ctx.check_hostname = False
				    ctx.verify_mode = SSL.VERIFY_NONE

				    sock_ssl = SSL.Connection(ctx, sock)
				    sock_ssl.set_connect_state()
				    sock_ssl.set_tlsext_host_name(hostname_idna)				    
				    sock_ssl.do_handshake()
				    cert = sock_ssl.get_peer_certificate()
				    crypto_cert = cert.to_cryptography()
				    sock_ssl.close()
				    sock.close()

				    return HostInfo(cert=crypto_cert, peername=peername, hostname=hostname)

				def get_alt_names(cert):
				    
				    try:
				        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName)
				        return ext.value.get_values_for_type(x509.DNSName)
				    except x509.ExtensionNotFound:
				        return None

				def get_common_name(cert):
				    
				    try:
				        names = cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)
				        return names[0].value
				    except x509.ExtensionNotFound:
				        return None

				def get_issuer(cert):
				    
				    try:
				        names = cert.issuer.get_attributes_for_oid(NameOID.COMMON_NAME)
				        return names[0].value
				    except x509.ExtensionNotFound:
				        return None


				def print_basic_info(hostinfo):


				    #print(hostinfo.cert.not_valid_after)
				    datetimes = hostinfo.cert.not_valid_after
				    datetimes = str(datetimes)
				    datetimes = datetimes.split(" ")
				    datetimes = datetimes[0].split("-")
				    present = datetime.now()
				    #print(datetimes[0])
				    #print(datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) < present)

				    s = '''\n» {hostname} « … {peername}
				    \tcommonName: {commonname}
				    \tSAN: {SAN}
				    \tissuer: {issuer}
				    \tnotBefore: {notbefore}
				    \tnotAfter:  {notafter}
				    '''.format(
				            hostname=hostinfo.hostname,
				            peername=hostinfo.peername,
				            commonname=get_common_name(hostinfo.cert),
				            SAN=get_alt_names(hostinfo.cert),
				            issuer=get_issuer(hostinfo.cert),
				            notbefore=hostinfo.cert.not_valid_before,
				            notafter=hostinfo.cert.not_valid_after
				    )
				    print(s)

				    if (datetime(int(datetimes[0]), int(datetimes[1]), int(datetimes[2])) < present) == True:
				    	print("\t-> Certificate Expired")
				    	instance = str(IP) + ":" + str(loopPorts)
				    	expiredCerts.update({instance:str(s)})
				    

				def check_it_out(hostname, port):
				    hostinfo = get_certificate(hostname, port)
				    print_basic_info(hostinfo)


				with concurrent.futures.ThreadPoolExecutor(max_workers=4) as e:
					for hostinfo in e.map(lambda x: get_certificate(x[0], x[1]), HOSTS):
						print_basic_info(hostinfo)
		
			
			except Exception as e:
				count = "buff!"
				#print(loopPorts)
				#print(e)
				
			anonCiphers(IP, loopPorts)
			httpsEnforced(IP, loopPorts)

		else:
			httpsEnforced(IP, loopPorts)



def portOpenCheck(IP, port):

	try:
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		result = sock.connect_ex((IP,int(port)))

	except:
		return False 
 

	if result == 0:
		return True
	else:
		return False

	sock.close()


#Make all the requests and send the response object to all methods.
def allRequests():
	print ("placeholder")


def extractPath(data, IP, port, fromMethod):

	regWin = (re.findall( r'([a-zA-Z]:)?(\\[a-zA-Z0-9_-]+)+\\?', str(data)))

	regLinux = (re.findall( r'^(/[^/ ]*)+/?$', str(data)))

	if regLinux == []:
		return

	else:
		print ("\t-> Internal Path Disclosure")
		instance = str(IP) + ":" + str(port)
		extractPathStore.update({instance:str(regLinux)})


	if regWin == []:
		return

	else:
		print ("\t-> Internal Path Disclosure")
		instance = str(IP) + ":" + str(port)
		extractPathStore.update({instance:str(regWin)})


def extractIP(extractIPFromString, IP, port, data):

	regex = (re.findall( r'(?:[\d]{1,3})\.(?:[\d]{1,3})\.(?:[\d]{1,3})\.(?:[\d]{1,3})', str(extractIPFromString)))
	import json

	for ip in regex:

		list_port = [ k for k in port ]
		if ip.startswith("10.") or ip.startswith("192.168."):
			print ("\t-> Internal IP Found")
			ipList.add(ip)

			if data == "iid":
				instance = str(IP) + ":" + str(list_port[0])
				internalIPDisclosureStore.update({instance:str(ip)})

			if data == "msfconsole":
				instance = str(IP) + ":" + str(list_port[0])
				bigIPDisclosureStore.update({instance:str(ip)})

		elif ip.startswith("172.") and int(ip.split(".")[1]) >= 16 and int(ip.split(".")[1]) <= 31:
			print ("\t-> Internal IP Found")
			ipList.add(ip)

			if data == "iid":
				instance = str(IP) + ":" + str(list_port[0])
				internalIPDisclosureStore.update({instance:str(ip)})

			if data == "msfconsole":
				instance = str(IP) + ":" + str(list_port[0])
				bigIPDisclosureStore.update({instance:str(ip)})
	
	return ipList


def msfconsole(IP, port):
	
	try:
		client = MsfRpcClient('toortoor', port=55553, ssl=True)
	except:
		return

	exploit = client.modules.use('auxiliary','gather/f5_bigip_cookie_disclosure')
	exploit['RHOSTS'] = IP
	exploit['RPORT'] = int(port)
	exploit['SSL']= False

	try:
		console_id = client.consoles.console().cid
		console = client.consoles.console(console_id)
		extractIP(console.run_module_with_output(exploit), IP, port, "msfconsole")

	except:
		print ("Connection failed")


def BIGIPcookieInformationDisclosure(IP, port):

	print ("\n[*] BIGIP Cookie Information Disclosure Check")
#	IP = "199.255.140.183"
	
	import nmap

	argument = "-Pn -p 55553"

	nm = nmap.PortScanner()
	nm.scan('127.0.0.1', arguments=argument)
	#print(nm['127.0.0.1']['tcp'][55553])
	p55553 = nm['127.0.0.1']['tcp'][55553]
	
	if p55553.get("state") == "open":
		print ("\t-> msfrpcd port open")
	else:
		print ("\t-> Starting msfrpcd on port 55553")
		os.system("msfrpcd -P toortoor")

	for loopPorts in port:
		msfconsole(IP, loopPorts)


def internalIPAddressDisclosure(IP, port, args):
	
	print ("\n[*] Internal  IP  Disclosure Check")

	headerName = randrange(100000000000)
	headerName = str(headerName)+"headers"
	headerName2 = randrange(100000000000)
	headerName2 = str(headerName2)+"headers2"
	contentName = randrange(100000000000)
	contentName = str(contentName)+"content"
	contentName2 = randrange(100000000000)
	contentName2 = str(contentName2)+"content2"

	for loopPorts in port:

		if args.proxy:		
			if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
		
				curlHeader = "curl --http1.0  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent --proxy "+args.proxy+" > "+headerName
				curlContent = "curl --http1.0  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent --proxy "+args.proxy+" > "+contentName
				curlHeader1 = "curl --http1.1  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent --proxy "+args.proxy+" > "+headerName2
				curlContent1 = "curl --http1.1  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent --proxy "+args.proxy+" > "+contentName2

			else:

				curlHeader = "curl --http1.0  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent --proxy "+args.proxy+" > "+headerName
				curlContent = "curl --http1.0  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent --proxy "+args.proxy+" > "+contentName
				curlHeader1 = "curl --http1.1  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent --proxy "+args.proxy+" > "+headerName2
				curlContent1 = "curl --http1.1  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent --proxy "+args.proxy+" >  "+contentName2

		else:
			if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
		
				curlHeader = "curl --http1.0  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent >  "+headerName
				curlContent = "curl --http1.0  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent > "+contentName
				curlHeader1 = "curl --http1.1  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent >  "+headerName2
				curlContent1 = "curl --http1.1  https://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent > "+contentName2

			else:

				curlHeader = "curl --http1.0  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent >  "+headerName
				curlContent = "curl --http1.0  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent > "+contentName
				curlHeader1 = "curl --http1.1  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure -I --silent >  "+headerName2
				curlContent1 = "curl --http1.1  http://"+IP+":"+loopPorts+" -H 'Accept-Charset: iso-8859-1,utf-8;q=0.9,*;q=0.1' -H 'Accept-Language: en' -H 'Host:' -H 'Connection: Keep-Alive' -H 'User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)' -H 'Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*' --insecure --silent > "+contentName2

		try:
			os.system(curlHeader)

			HeaderFileName = "./"+headerName
			with open(HeaderFileName) as f:
				for line in f:
					found = extractIP(line, IP, port, "iid")
					extractPath(line, IP, port, "iid")

			os.system(curlContent)

			ContentFileName = "./"+contentName
			with open(HeaderFileName) as f:
				for line in f:
					found = extractIP(line, IP, port, "iid")
					extractPath(line, IP, port, "iid")

			os.system(curlHeader1)

			HeaderFileName = "./"+headerName2
			with open(HeaderFileName) as f:
				for line in f:
					found = extractIP(line, IP, port, "iid")
					extractPath(line, IP, port, "iid")

			os.system(curlContent1)

			ContentFileName = "./"+contentName
			with open(HeaderFileName) as f:
				for line in f:
					found = extractIP(line, IP, port, "iid")
					extractPath(line, IP, port, "iid")

			os.remove("./"+headerName)
			os.remove("./"+headerName2)
			os.remove("./"+contentName)
			os.remove("./"+contentName2)

		except Exception as e:
			print ("\t-> Error while attempting IP Disclosure: "+str(e))

		

def hstsCheck(data, IP, port):
		
	if 'strict-transport-security' not in data.headers:
		print("	-> HSTS Header Missing")
		instance = str(IP) + ":" + str(port)
		HSTSMisconfig.update({instance:"Missing"})

	else:
		values = data.headers['strict-transport-security']
		max_age = int("".join(filter(str.isdigit, values)))
		
		if 'max-age' not in data.headers['strict-transport-security'] or max_age < 10886400:
			print ("\t-> HSTS not implemented properly: max-age should be at least eighteen weeks")
			instance = str(IP) + ":" + str(loopPorts)
			HSTSMisconfig.update({instance:"Misconfigured"})

		else:
			print ("\t-> HSTS implemented correctly")


def hsts(IP, port):

	print ("\n[*] Strict Transport Security Header Check")

	ssladdress = "https://"+str(IP)

	for loopPorts in port:
		#print(port.get(loopPorts))
		if "https" or "ssl" in port.get(loopPorts):

			ssladdress = "https://"+str(IP)+":"+loopPorts

			try:
				dataSSL = requests.get(ssladdress,  proxies=proxyDict, verify=False, allow_redirects=False, timeout=(5, 14))

				hstsCheck(dataSSL, IP, loopPorts)

			except requests.exceptions.RequestException as e:
				exception = 1

		else:
			return



def verboseServerBannerCheck(data, IP, protocol, port):
	
	if "Server" in data.headers:
	
		if data.headers["Server"] != "":
			print ("\t-> Verbose Server Banner: "+protocol+":"+port)
			instance = str(IP) + ":" + str(port)
			banner = "Server: "+data.headers["Server"]
			verboseServerBannerStore.update({instance:banner})

			if "apache" in  str(data.headers['Server']).lower():
				
				print("\t\t-> Apache server")
				if "/" in data.headers['Server']:
					splitValue = data.headers['Server'].split('/')
					#output = subprocess.check_output(['searchsploit',splitValue[0],splitValue[1]])
					#instance = str(IP) + ":" + str(port)
					#searchsploitResults.update({instance:output})
					
				else:
					output = subprocess.check_output(['searchsploit',data.headers['Server']])
					#instance = str(IP) + ":" + str(port)
					#searchsploitResults.update({instance:output})
					

			elif "iis" in  str((data.headers['Server'])).lower():
				print("\t\t-> IIS server")

				if "/" in data.headers['Server']:
					splitValue = data.headers['Server'].split('/')
					#output = subprocess.check_output(['searchsploit',splitValue[0],splitValue[1]])
					#instance = str(IP) + ":" + str(port)
					#searchsploitResults.update({instance:output})

				else:
					output = subprocess.check_output(['searchsploit',data.headers['Server']])
					#instance = str(IP) + ":" + str(port)
					#searchsploitResults.update({instance:output})

			else:
				print("\t\t-> Unknown Server")
				if "/" in data.headers['Server']:
					splitValue = data.headers['Server'].split('/')
					#output = subprocess.check_output(['searchsploit',splitValue[0],splitValue[1]])
					#instance = str(IP) + ":" + str(port)
					#searchsploitResults.update({instance:output})

				else:
					output = subprocess.check_output(['searchsploit',data.headers['Server']])
					#instance = str(IP) + ":" + str(port)
					#searchsploitResults.update({instance:output})


		if "X-AspNet-Version" in data.headers:
			if data.headers["X-AspNet-Version"] != "":
				print("\t-> Verbose Software Version: "+protocol)
				instance = str(IP) + ":" + str(port)
				banner = "X-AspNet-Version: "+data.headers["X-AspNet-Version"]
				verboseServerBannerStore.update({instance:banner})

		if "X-Powered-By" in data.headers:
			if data.headers["X-Powered-By"] != "":
				print("\t-> Verbose Server Banner: "+protocol) 
				instance = str(IP) + ":" + str(port)
				banner = "X-Powered-By: "+data.headers["X-Powered-By"]
				verboseServerBannerStore.update({instance:banner})

		customAddress = "http://"+IP+"/customdirectory"
		customAddresshttps = "https://"+IP+"/customdirectory"
		customAddress1 = "http://"+IP+"/customdirectory!@$%^&*()_+-=[]/{/}|;':/,./?><~`"
		customAddresshttps1 = "https://"+IP+"/customdirectory!@$%^&*()_+-=[]/{/}|;':/,./?><~`"
		customAddressUserAgent = "http://"+IP
		customAddresshttpsUserAgent = "https://"+IP

		headers = {'Host': IP, 'Upgrade-Insecure-Requests':'1', \
	'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
	'Accept-Encoding':'gzip, deflate',\
	'User-Agent':"() { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'",\
	'Connection': 'close'} 
		
		headers1 = {'Host': '<script>alert()</script>', 'Upgrade-Insecure-Requests':'1', \
	'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
	'Accept-Encoding':'gzip, deflate',\
	'User-Agent':"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36",\
	'Connection': 'close'} 

		try:
			data = requests.get(customAddress, proxies=proxyDict, verify=False, allow_redirects=False, timeout=(5, 14))

			if "apache" in str((data.content)).lower() or "asp.net" in str((data.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = str(IP) + ":" + str(port)
				verboseServerBannerContentStore.update({instance:str(data.request.headers)})

	
		except requests.exceptions.RequestException as e:
			exception = 1
			#print(e)
		
		try:
			data1 = requests.get(customAddresshttps,  proxies=proxyDict,verify=False, allow_redirects=False, timeout=(5, 14))

			if "apache" in str((data1.content)).lower() or "asp.net" in str((data1.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = str(IP) + ":" + str(port)
				verboseServerBannerContentStore.update({instance:str(data1.request.headers)})

		except requests.exceptions.RequestException as e:
			exception = 1
			#print(e)

		try:
			dataCustom = requests.get(customAddress1, verify=False, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
			
			if "apache" in str((dataCustom.content)).lower() or "asp.net" in str((dataCustom.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = str(IP) + ":" + str(port)
				verboseServerBannerContentStore.update({instance:str(dataCustom.request.headers)})

		except requests.exceptions.RequestException as e:
			exception = 1
			#print(e)

		try:
			dataCustom1 = requests.get(customAddresshttps1, verify=False,  proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
			
			if "apache" in str((dataCustom1.content)).lower() or "asp.net" in str((dataCustom1.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = str(IP) + ":" + str(port)
				verboseServerBannerContentStore.update({instance:str(dataCustom1.request.headers)})

		except requests.exceptions.RequestException as e:
			exception = 1
			#print(e)

		try:
			dataCustomUA = requests.get(customAddressUserAgent, headers=headers, proxies=proxyDict, verify=False, allow_redirects=False, timeout=(5, 14))

			if "stack trace" in str((dataCustomUA)).lower() or "exception" in str((dataCustomUA.content)).lower() or "javax.servlet" in str((dataCustomUA.content)).lower():
				print ("\t-> Verbose Server Error")
				instance = str(IP) + ":" + str(port)
				payload = "Possible Stack trace, please check\n\n" + dataCustomUA.request.headers
				verboseServerErrorStore.update({instance:str(dataCustomUA.request.headers)})

			if "apache" in str((dataCustomUA)).lower() or "asp.net" in str((dataCustomUA.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = str(IP) + ":" + str(port)
				verboseServerBannerContentStore.update({instance:str(dataCustomUA.request.headers)})


		except requests.exceptions.RequestException as e:
			exception = 1
			#print(e)

		try:
			dataCustomUA1 = requests.get(customAddresshttpsUserAgent, headers=headers, proxies=proxyDict, verify=False, allow_redirects=False, timeout=(5, 14))

			if "stack trace" in str((dataCustomUA1)).lower() or "exception" in str((dataCustomUA1.content)).lower() or "javax.servlet" in str((dataCustomUA1.content)).lower():
				print ("\t-> Verbose Server Error")
				instance = str(IP) + ":" + str(port)
				payload = "Possible Stack trace, please check\n\n" + dataCustomUA1.request.headers
				verboseServerErrorStore.update({instance:str(dataCustomUA1.request.headers)})

			if "apache" in str((dataCustomUA1)).lower() or "asp.net" in str((dataCustomUA1.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = str(IP) + ":" + str(port)
				verboseServerBannerContentStore.update({instance:str(dataCustomUA1.request.headers)})
			
		except requests.exceptions.RequestException as e:
			exception = 1
			#print(e)
		
		try:
			dataCustomHost = requests.get(customAddressUserAgent, headers=headers1, proxies=proxyDict, verify=False, allow_redirects=False, timeout=(5, 14))

			if "apache" in str((dataCustomHost)).lower() or "asp.net" in str((dataCustomHost.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = str(IP) + ":" + str(port)
				verboseServerBannerContentStore.update({instance:str(dataCustomHost.request.headers)})

		except requests.exceptions.RequestException as e:
			exception = 1
			#print(e)
		
		try:
			dataCustomHost1 = requests.get(customAddresshttpsUserAgent, headers=headers1, proxies=proxyDict, verify=False, allow_redirects=False, timeout=(5, 14))

			if "apache" in str((dataCustomHost1)).lower() or "asp.net" in str((dataCustomHost1.content)).lower():
				print ("\t-> Verbose Server Banner in content")
				instance = str(IP) + ":" + str(port)
				verboseServerBannerContentStore.update({instance:str(dataCustomHost1.request.headers)})

		except requests.exceptions.RequestException as e:
			exception = 1
			#print(e)

	

def VerboseServerBanner(IP, port):

	print ("\n[*] Verbose Server Banner Check")

	headers = {'Host': IP, 'Upgrade-Insecure-Requests':'1', \
'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\
'Accept-Encoding':'gzip, deflate',\
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 


	for loopPorts in port:

		if int(loopPorts) != 443 and int(loopPorts) != 80:
			
			if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
				
				SSLaddress = "https://"+str(IP)+":"+loopPorts

				try:
					dataSSL = requests.get(SSLaddress, headers=headers, proxies=proxyDict, verify=False, allow_redirects=False, timeout=(30, 34))

					verboseServerBannerCheck(dataSSL, IP, "https", loopPorts)
					extractPath(dataSSL.content, IP, loopPorts, "vsb")
					extractPath(dataSSL.headers, IP, loopPorts, "vsb")

				except:

					proxyError(e, "")
					continue

		if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):

			if int(loopPorts) == 443 or int(loopPorts) == 80:
				
				SSLaddress = "https://"+str(IP)

				try:
					dataSSL = requests.get(SSLaddress, headers=headers, proxies=proxyDict, verify=False, allow_redirects=False, timeout=(30, 34))

					verboseServerBannerCheck(dataSSL, IP, "https", loopPorts)
					extractPath(dataSSL.content, IP, loopPorts, "vsb")
					extractPath(dataSSL.headers, IP, loopPorts, "vsb")


				except Exception as e:
					
					proxyError(e, "")
					continue
		else:
			
			address = "http://"+str(IP)+":"+loopPorts

			try:
				data = requests.get(address, headers=headers,  proxies=proxyDict, verify=False, allow_redirects=False, timeout=(30, 34))

				verboseServerBannerCheck(data, IP, "http", loopPorts)
				extractPath(data.content, IP, loopPorts, "vsb")
				extractPath(data.headers, IP, loopPorts, "vsb")

			except Exception as e:

				proxyError(e, "")
				continue



def hostHeaderInjection(IP, port):

	print ("\n[*] Host Header Injection Check")

	headers = {'Host': 'www.oteri.com', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	for loopPorts in port:
		#print(port.get(loopPorts))
		if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
			if int(loopPorts) != 443 and int(loopPorts) != 80:

				addreSSL = "https://"+str(IP)+":"+loopPorts

				try:
					injectionSSL = requests.get(addreSSL, verify=False, proxies=proxyDict, headers=headers, allow_redirects=False, timeout=(5, 14))
				
					if "location" in str((injectionSSL.headers)).lower():

						if "oteri" in injectionSSL.headers['Location']:
							#print(injectionSSL.headers['Location'])
							print ("\t-> Host Header Injection Successful")
							instance = str(IP) + ":" + str(loopPorts)
							payloadLocation = "Reflected in the location header\n\nRequest Headers:\n"+str(injectionSSL.request.headers)
							hostHeaderInjectionStore.update({instance:payloadLocation})

						if "oteri" in str(injectionSSL.content):
							print("\t-> Host header value reflected in body")
							instance = str(IP) + ":" + str(loopPorts)
							payloadLocation = "Reflected in the body of the response\n\nRequest Headers:\n"+str(injectionSSL.request.headers)
							hostHeaderInjectionStore.update({instance:payloadLocation})

				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue

		if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
			if int(loopPorts) == 443 or int(loopPorts) == 80:

				addreSSL = "https://"+str(IP)

				try:
					injectionSSL = requests.get(addreSSL, verify=False, proxies=proxyDict, headers=headers, allow_redirects=False, timeout=(5, 14))
				
					if "location" in str((injectionSSL.headers)).lower():

						if "oteri" in injectionSSL.headers['Location']:
							print ("\t-> Host Header Injection Successful")
							instance = str(IP) + ":" + str(loopPorts)
							payloadLocation = "Reflected in location header\n\nRequest Headers:\n"+str(injectionSSL.request.headers)
							hostHeaderInjectionStore.update({instance:payloadLocation})

						if "oteri" in str(injectionSSL.content):
							print("\t-> Host header value reflected in body")
							instance = str(IP) + ":" + str(loopPorts)
							payloadLocation = "Reflected in the body of the response\n\nRequest Headers:\n"+str(injectionSSL.request.headers)
							hostHeaderInjectionStore.update({instance:payloadLocation})

				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue


		else:

			address = "http://"+str(IP)+":"+loopPorts
			#print(address)

			try:
				injection = requests.get(address, verify=False, proxies=proxyDict, headers=headers, allow_redirects=False, timeout=(5, 14))
			
				if "location" in str((injection.headers)).lower():

					if "oteri" in injection.headers['Location']:
						print ("\t-> Host Header Injection Successful")
						instance = str(IP) + ":" + str(loopPorts)
						payloadLocation = "Reflected in the location header\n\nRequest Headers:\n"+str(injection.request.headers)
						hostHeaderInjectionStore.update({instance:payloadLocation})

					if "oteri" in str(injection.content):
						print("\t-> Host header value reflected in body")
						instance = str(IP) + ":" + str(loopPorts)
						payloadLocation = "Reflected in the body of the response\n\nRequest Headers:\n"+str(injection.request.headers)
						hostHeaderInjectionStore.update({instance:payloadLocation})


			except requests.exceptions.RequestException as e:
				exception = 1
				proxyError(e, "")
				continue


def	ssrf(IP, port):

	print ("\n[*] Server Side Request Forgery Check")

	headers = {'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersValid = {'Host': '8.8.8.8', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersInvalid = {'Host': '8.8.8.81', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersValidloop = {'Host': '127.0.0.1', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 

	headersInvalidloop = {'Host': '127.0.0.11', 'Upgrade-Insecure-Requests':'1', \
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',\
'Connection': 'close'} 


	status1 = ""
	status2 = ""
	status3 = ""
	status4 = ""

	for loopPorts in port:
		#print(port.get(loopPorts))
		if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
			if int(loopPorts) != 443 and int(loopPorts) != 80:

				addreSSL = "https://"+str(IP)+":"+loopPorts

				try:
					address = "https://"+str(IP)+":"+loopPorts+"/http://www.google.com"
					address1 = "https://"+str(IP)+":"+loopPorts+"/http://www.oteri420.com"

					injectionSSL = requests.get(address, verify=False, headers=headersValid, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
					injectionSSL1 = requests.get(address1, verify=False, headers=headersValid, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))

					test1 = injectionSSL.status_code
					test2 = injectionSSL1.status_code

					if test1 != test2:
						print ("\t-> Vulnerable to SSRF")
						instance = str(IP) + ":" + str(loopPorts)
						payloadLocation = "Injected in URL\n\nURL: "+address+"\n"+"Request Headers:\n"+str(injectionSSL.request.headers)+"\n\nURL: "+address1+"\n"+str(injectionSSL1.request.headers)
						ssrfStore.update({instance:payloadLocation})

					if "Google Search" in str(injectionSSL.content) or "I'm Feeling Lucky" in str(injectionSSL.content):
						print ("\t-> Vulnerable to SSRF")
						instance = str(IP) + ":" + str(loopPorts)
						payloadLocation = "Injected in URL\n\nURL: "+address+"\n"+"Request Headers:\n"+str(injectionSSL.request.headers)+"\n\nURL: "+address1+"\n"+str(injectionSSL1.request.headers)
						ssrfStore.update({instance:payloadLocation})


				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue

				try:
					injectionSSL2 = requests.get(addreSSL, verify=False, headers=headersValid, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
				
					status1 = injectionSSL2.status_code

				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue

				try:
					injectionSSL3 = requests.get(addreSSL, verify=False, headers=headersInvalid, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
				
					status2 = injectionSSL3.status_code

				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue

				try:
					injectionSSL4 = requests.get(addreSSL, verify=False, headers=headersValidloop, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
				
					status3 = injectionSSL4.status_code

				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue

				try:
					injectionSSL5 = requests.get(addreSSL, verify=False, headers=headersInvalidloop, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
				
					status4 = injectionSSL5.status_code

				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue

				resultSSRF = set((status1, status2, status3, status4))


				if len(resultSSRF) > 1:

					if status1 == status3 and status2 == status4:
					
						print ("\t-> Vulnerable to SSRF")
						instance = str(IP) + ":" + str(loopPorts)
						payloadLocation = "Injected in the Host header\n\nURL: "+addreSSL+"\n"+"Request Headers:\n"+str(injectionSSL2.request.headers)+"\n\nURL: "+addreSSL+"\n"+str(injectionSSL3.request.headers)+"\n\nURL: "+addreSSL+"\n"+str(injectionSSL4.request.headers)+"\n\nURL: "+addreSSL+"\n"+str(injectionSSL5.request.headers)
						ssrfStore.update({instance:payloadLocation})


		if "https" in port.get(loopPorts) or "ssl" in port.get(loopPorts):
			if int(loopPorts) == 443 or int(loopPorts) == 80:

				addreSSL = "https://"+str(IP)

				try:
					address = "https://"+str(IP)+"/http://www.google.com"
					address1 = "https://"+str(IP)+"/http://www.oteri420.com"

					injectionSSL = requests.get(address, verify=False, headers=headersValid,  proxies=proxyDict,allow_redirects=False, timeout=(5, 14))
					injectionSSL1 = requests.get(address1, verify=False, headers=headersValid,  proxies=proxyDict,allow_redirects=False, timeout=(5, 14))

					test1 = injectionSSL.status_code
					test2 = injectionSSL1.status_code

					if test1 != test2:
						print ("\t-> Vulnerable to SSRF")
						instance = str(IP) + ":" + str(loopPorts)
						payloadLocation = "Injected in URL\n\nURL: "+address+"\n"+"Request Headers:\n"+str(injectionSSL.request.headers)+"\n\nURL: "+address1+"\n"+str(injectionSSL1.request.headers)
						ssrfStore.update({instance:payloadLocation})

						
				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue				

				try:
					injectionSSL2 = requests.get(addreSSL, verify=False, headers=headersValid, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
				
					status1 = injectionSSL2.status_code

				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue

				try:
					injectionSSL3 = requests.get(addreSSL, verify=False, headers=headersInvalid, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
				
					status2 = injectionSSL3.status_code

				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue

				try:
					injectionSSL4 = requests.get(addreSSL, verify=False, headers=headersValidloop,  proxies=proxyDict,allow_redirects=False, timeout=(5, 14))

					status3 = injectionSSL4.status_code

				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue

				try:
					injectionSSL5 = requests.get(addreSSL, verify=False, headers=headersInvalidloop, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))

					status4 = injectionSSL5.status_code

				except requests.exceptions.RequestException as e:
					exception = 1
					proxyError(e, "")
					continue

				resultSSRF = set((status1, status2, status3, status4))

				if len(resultSSRF) > 1:
				
					if status1 == status3 and status2 == status4:
				
						print ("\t-> Vulnerable to SSRF")
						instance = str(IP) + ":" + str(loopPorts)
						payloadLocation = "Injected in the Host header\n\nURL: "+addreSSL+"\n"+"Request Headers:\n"+str(injectionSSL2.request.headers)+"\n\nURL: "+addreSSL+"\n"+str(injectionSSL3.request.headers)+"\n\nURL: "+addreSSL+"\n"+str(injectionSSL4.request.headers)+"\n\nURL: "+addreSSL+"\n"+str(injectionSSL5.request.headers)
						ssrfStore.update({instance:payloadLocation})


		else:

			#print(address)

			try:
				address = "http://"+str(IP)+":"+loopPorts+"/http://www.google.com"
				address1 = "http://"+str(IP)+":"+loopPorts+"/http://www.oteri420.com"

				injectionSSL = requests.get(address, verify=False, headers=headersValid, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
				injectionSSL1 = requests.get(address1, verify=False, headers=headersValid, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))

				test1 = injectionSSL.status_code
				test2 = injectionSSL1.status_code

				if test1 != test2:
					print ("\t-> Vulnerable to SSRF")
					instance = str(IP) + ":" + str(loopPorts)
					payloadLocation = "Injected in URL\n\nURL: "+address+"\n"+"Request Headers:\n"+str(injectionSSL.request.headers)+"\n\nURL: "+address1+"\n"+str(injectionSSL1.request.headers)
					ssrfStore.update({instance:payloadLocation})

					
			except requests.exceptions.RequestException as e:
				exception = 1
				proxyError(e, "")
				continue

			address = "http://"+str(IP)+":"+loopPorts
			try:
				injectionSSL2 = requests.get(address, verify=False, headers=headersValid,  proxies=proxyDict,allow_redirects=False, timeout=(5, 14))
			
				status1 = injectionSSL2.status_code

			except requests.exceptions.RequestException as e:
				exception = 1
				proxyError(e, "")
				continue

			try:
				injectionSSL3 = requests.get(address, verify=False, headers=headersInvalid, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
			
				status2 = injectionSSL3.status_code

			except requests.exceptions.RequestException as e:
				exception = 1
				proxyError(e, "")
				continue

			try:
				injectionSSL4 = requests.get(address, verify=False, headers=headersValidloop, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
			
				status3 = injectionSSL4.status_code

			except requests.exceptions.RequestException as e:
				exception = 1
				proxyError(e, "")
				continue

			try:
				injectionSSL5 = requests.get(address, verify=False, headers=headersInvalidloop, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))
			
				status4 = injectionSSL5.status_code

			except requests.exceptions.RequestException as e:
				exception = 1
				proxyError(e, "")
				continue

			resultSSRF = set((status1, status2, status3, status4))

			if len(resultSSRF) > 1:
				
				if status1 == status3 and status2 == status4:
					
					print ("\t-> Vulnerable to SSRF")
					instance = str(IP) + ":" + str(loopPorts)
					payloadLocation = "Injected in the Host header\n\nURL: "+address+"\n"+"Request Headers:\n"+str(injectionSSL2.request.headers)+"\n\nURL: "+address+"\n"+str(injectionSSL3.request.headers)+"\n\nURL: "+address+"\n"+str(injectionSSL4.request.headers)+"\n\nURL: "+address+"\n"+str(injectionSSL5.request.headers)
					ssrfStore.update({instance:payloadLocation})


		resultSSRF = set()
		status1 = ""
		status2 = ""
		status3 = ""
		status4 = ""



def worksheetFill():

	worksheet.set_default_row(25)
	worksheetWeb.set_default_row(25)


	row = 2
	col = 0
	for key,value in expiredCerts.items():
		worksheet.write(row, col, key, cell_format)
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format) 
		worksheet.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 4
	for key,value in anonCiphersStore.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 8
	for key,value in httpsNotEnabled.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 12
	for key,value in httpsNotEnforced.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 16
	for key,value in HSTSMisconfig.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		worksheet.write(row, col+1, value, cell_format)
		worksheet.set_column(row, col+1, 25) 
		row +=1

	row = 2
	col = 20
	for key,value in SSL2.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 21
	for key,value in SSL3.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 22
	for key,value in TLS1.items():
		worksheet.write(row, col, key, cell_format) 
		worksheet.set_column(row, col, 25)
		row +=1

	row = 2
	col = 0
	for key,value in verboseServerBannerStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 4
	for key,value in verboseServerBannerContentStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 8
	for key,value in hostHeaderInjectionStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 12
	for key,value in internalIPDisclosureStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 16
	for key,value in bigIPDisclosureStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 20
	for key,value in ssrfStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 24
	for key,value in verboseServerErrorStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 28
	for key,value in extractPathStore.items():
		worksheetWeb.write(row, col, key, cell_format) 
		worksheetWeb.set_column(row, col, 25)
		worksheetWeb.write(row, col+1, value, cell_format) 
		worksheetWeb.set_column(row, col+1, 25)
		row +=1

	row = 2
	col = 0
	for key,value in ntpStore.items():
		worksheetNetwork.write(row, col, key, cell_format) 
		worksheetNetwork.set_column(row, col, 25)
		worksheetNetwork.write(row, col+1, value, cell_format) 
		worksheetNetwork.set_column(row, col+1, 25)
		row +=1


def enumerate(IP, port, args):

	ssl(IP, port)
	VerboseServerBanner(IP, port)
	hostHeaderInjection(IP, port)
	hsts(IP,port)
	internalIPAddressDisclosure(IP, port, args)
	#BIGIPcookieInformationDisclosure(IP, port)
	ssrf(IP, port)
	ntpMode6(IP)
	

def nmap(IP, port):

	import nmap

	storeOpenPorts = {}

	argument = "-Pn -p80,443,8443,8080,"+str(port)

	nm = nmap.PortScanner()
	nm.scan(IP, arguments=argument)

	#print(nm[IP]['tcp'][80])
	p80 = nm[IP]['tcp'][80]
	#print(nm[IP]['tcp'][443])
	p443 = nm[IP]['tcp'][443]
	#print(nm[IP]['tcp'][8080])
	p8080 = nm[IP]['tcp'][8080]
	#print(nm[IP]['tcp'][8443])
	p8443 = nm[IP]['tcp'][8443]

	if p80.get("state") == "open":
		storeOpenPorts.update({"80":p80.get("name")})

	if p443.get("state") == "open":
		storeOpenPorts.update({"443":p443.get("name")})

	if p8080.get("state") == "open":
		storeOpenPorts.update({"8080":p8080.get("name")})

	if p8443.get("state") == "open":
		storeOpenPorts.update({"8443":p8443.get("name")})


	if port.strip() != "":
		
		if "," in port:
			port = port.split(",")
			#print(port)

			for i in port:
				pCustom = ""
				pCustom = nm[IP]['tcp'][int(i)]

				if pCustom.get("state") == "open":
					storeOpenPorts.update({i:pCustom.get("name")})

		else:
			pCustom = ""
			pCustom = nm[IP]['tcp'][int(port)]
			if pCustom.get("state") == "open":
				storeOpenPorts.update({port:pCustom.get("name")})


	#print(storeOpenPorts)
	return storeOpenPorts


def startScan(args, ip):

	print ("\n\nScanning: "+ip)

	if args.port:
		openPorts = nmap(ip, args.port)
	else:
		port=""
		openPorts = nmap(ip, port)


	if args.full:
		
		enumerate(ip, openPorts, args)

	else:

		port = ""
		if args.hsts:
			hsts(ip, openPorts)
		if args.hhi:
			hostHeaderInjection(ip, openPorts)
		if args.vsb:
			VerboseServerBanner(ip, openPorts)
		if args.bigip:
			BIGIPcookieInformationDisclosure(ip, openPorts)
		if args.iid:
			internalIPAddressDisclosure(ip, openPorts, args)
		if args.ssl:
			ssl(ip, openPorts)
		if args.ssrf:
			ssrf(ip, openPorts)
		if args.ntp:
			ntpMode6(ip)


def arguments(args):

	global proxyDict

	if args.proxy:
		
		proxyValHttp = "http://"+args.proxy
		proxyValHttps = "https://"+args.proxy

		proxyDict = { 
          "http"  : proxyValHttp, 
          "https" : proxyValHttps
        	}

		try:
			address = "https://www.google.com"
			proxyCheck = requests.get(address, verify=False, proxies=proxyDict, allow_redirects=False, timeout=(5, 14))

		except Exception as e:
			
			proxyError(e, "scan")
			
	else:
		proxyDict = {}


	#Multi-Threading 
	q = queue.Queue()

	def threader():

		while True:
			worker = q.get()

			if worker is None:
				break

			startScan(args, worker)
			
			q.task_done()


	if args.threads:
		if int(args.threads) >= 21:
			print("\nMax 20 threads allowed\n")
			numberOfThreads = 20
		else:
			numberOfThreads = int(args.threads)

	else:
		numberOfThreads = 1

	threads = []

	for x in range(int(numberOfThreads)):
	     
		t = threading.Thread(target=threader)
		t.daemon = True
		t.start()

		threads.append(t)
		

	with open(args.filename) as f:
			
		for ip in f:
			ip = ip.strip()

			if ip == "":
				continue
			else:
				q.put(ip)

	q.join()
	
	for i in range(numberOfThreads):
	    q.put(None)

	
	for t in threads:
		t.join()


if len(sys.argv) < 3:

	sys.argv.append('--help')

parser = argparse.ArgumentParser()
parser.add_argument('filename', help="file path with ip addresses to scan")
parser.add_argument('--port', help='scan custom port, use comma-seperated values for multiple ports')
parser.add_argument('--proxy', help='use an intercepting proxy, provide IP and Port number. eg. --proxy 127.0.0.1:8080')
parser.add_argument('--threads', help='number of threads to use: default 1, maximum 20')
parser.add_argument('--bigip', help='check if BIGIP cookie is present and whether it is vulnerable to information disclosure',  action="store_true")
parser.add_argument('--full', help='scan for all options given below',  action="store_true")
parser.add_argument('--hsts', help='check if the "strict-transport-security" header is present',  action="store_true")
parser.add_argument('--hhi', help='check if application is vulnerable to Host Header Injection',  action="store_true")
parser.add_argument('--vsb', help='check if the application returns a verbose server banner',  action="store_true")
parser.add_argument('--iid', help='check if the application discloses internal ip addresses',  action="store_true")
parser.add_argument('--ssl', help="check if there are ssl related vulnerabilities or misconfigurations",   action="store_true")
parser.add_argument('--ssrf', help="response based detection for server side request forgery",   action="store_true")
parser.add_argument('--ntp', help='check if the remote NTP server responds to mode 6 queries',  action="store_true")

args = parser.parse_args()

arguments(args)
worksheetFill()
workbook.close() 
ipList = set()

end = time.time()
print("\nTotal Runtime of Script: ")
print(end - start)

#os.kill(os.getppid(), signal.SIGHUP)
'''
IPAddressFile = sys.argv[1]

with open(IPAddressFile) as file:
	for IP in file:
		print ("IP")
		enumerate(IP)

'''

#hostHeaderInjection()
#hsts()
#VerboseServerBanner()
#internalIPAddressDisclosure()
#BIGIPcookieInformationDisclosure()

'''			allPortsToScan = ""
			count = 0

			for i in openPorts:
				allPortsToScan += i
				if count == len(openPorts)-1:
					break		
				allPortsToScan += ","
			print(allPortsToScan)

			if args.port:
				if args.full:
					enumerate(ip, args.port)
				else:
					if args.hsts:
						hsts(ip, args.port)
					if args.hhi:
						hostHeaderInjection(ip, args.port)
					if args.vsb:
						VerboseServerBanner(ip, args.port)
					if args.bigip:
						BIGIPcookieInformationDisclosure(ip, args.port)
					if args.iid:
						internalIPAddressDisclosure(ip, args.port)
'''			
